<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>underworld3.systems.ddt API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>underworld3.systems.ddt</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="underworld3.systems.ddt.Lagrangian"><code class="flex name class">
<span>class <span class="ident">Lagrangian</span></span>
<span>(</span><span>mesh: <a title="underworld3.discretisation.Mesh" href="../discretisation.html#underworld3.discretisation.Mesh">Mesh</a>, psi_fn: sympy.core.function.Function, V_fn: sympy.core.function.Function, vtype: underworld3._var_types.VarType, degree: int, continuous: bool, varsymbol: Optional[str] = 'u', verbose: Optional[bool] = False, bcs=[], order=1, smoothing=0.0, fill_param=3)</span>
</code></dt>
<dd>
<div class="desc"><p>Swarm-based Lagrangian History Manager:</p>
<p>This manages the update of a Lagrangian variable, $\psi$ on the swarm across timesteps.</p>
<p>$\quad \psi_p^{t-n\Delta t} \leftarrow \psi_p^{t-(n-1)\Delta t}\quad$</p>
<p>$\quad \psi_p^{t-(n-1)\Delta t} \leftarrow \psi_p^{t-(n-2)\Delta t} \cdots\quad$</p>
<p>$\quad \psi_p^{t-\Delta t} \leftarrow \psi_p^{t}$</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lagrangian(uw_object):
    r&#34;&#34;&#34;Swarm-based Lagrangian History Manager:

    This manages the update of a Lagrangian variable, $\psi$ on the swarm across timesteps.

    $\quad \psi_p^{t-n\Delta t} \leftarrow \psi_p^{t-(n-1)\Delta t}\quad$

    $\quad \psi_p^{t-(n-1)\Delta t} \leftarrow \psi_p^{t-(n-2)\Delta t} \cdots\quad$

    $\quad \psi_p^{t-\Delta t} \leftarrow \psi_p^{t}$
    &#34;&#34;&#34;

    instances = 0  # count how many of these there are in order to create unique private mesh variable ids

    @timing.routine_timer_decorator
    def __init__(
        self,
        mesh: uw.discretisation.Mesh,
        psi_fn: sympy.Function,
        V_fn: sympy.Function,
        vtype: uw.VarType,
        degree: int,
        continuous: bool,
        varsymbol: Optional[str] = r&#34;u&#34;,
        verbose: Optional[bool] = False,
        bcs=[],
        order=1,
        smoothing=0.0,
        fill_param=3,
    ):
        super().__init__()

        # create a new swarm to manage here
        dudt_swarm = uw.swarm.Swarm(mesh)

        self.mesh = mesh
        self.swarm = dudt_swarm
        self.psi_fn = psi_fn
        self.V_fn = V_fn
        self.verbose = verbose
        self.order = order

        psi_star = []
        self.psi_star = psi_star

        for i in range(order):
            print(f&#34;Creating psi_star[{i}]&#34;)
            self.psi_star.append(
                uw.swarm.SwarmVariable(
                    f&#34;psi_star_sw_{self.instance_number}_{i}&#34;,
                    self.swarm,
                    vtype=vtype,
                    proxy_degree=degree,
                    proxy_continuous=continuous,
                    varsymbol=rf&#34;{varsymbol}^{{ {&#39;*&#39;*(i+1)} }}&#34;,
                )
            )

        dudt_swarm.populate(fill_param)

        return

    def _object_viewer(self):
        from IPython.display import Latex, Markdown, display

        super()._object_viewer()

        ## feedback on this instance
        display(Latex(r&#34;$\quad\psi = $ &#34; + self.psi._repr_latex_()))
        display(
            Latex(
                r&#34;$\quad\Delta t_{\textrm{phys}} = $ &#34;
                + sympy.sympify(self.dt_physical)._repr_latex_()
            )
        )
        display(Latex(rf&#34;$\quad$History steps = {self.order}&#34;))

    ## Note: We may be able to eliminate this
    ## The SL updater and the Lag updater have
    ## different sequencing because of the way they
    ## update the history. It makes more sense for the
    ## full Lagrangian swarm to be updated after the solve
    ## and this means we have to grab the history values first.

    def update(
        self,
        dt: float,
        evalf: Optional[bool] = False,
        verbose: Optional[bool] = False,
    ):
        self.update_post_solve(dt, evalf, verbose)
        return

    def update_pre_solve(
        self,
        dt: float,
        evalf: Optional[bool] = False,
        verbose: Optional[bool] = False,
    ):
        return

    def update_post_solve(
        self,
        dt: float,
        evalf: Optional[bool] = False,
        verbose: Optional[bool] = False,
    ):
        for h in range(self.order - 1):
            i = self.order - (h + 1)

            # copy the information down the chain
            print(f&#34;Lagrange order = {self.order}&#34;)
            print(f&#34;Lagrange copying {i-1} to {i}&#34;)

            with self.swarm.access(self.psi_star[i]):
                self.psi_star[i].data[...] = self.psi_star[i - 1].data[...]

        # Now update the swarm variable

        if evalf:
            psi_star_0 = self.psi_star[0]
            with self.swarm.access(psi_star_0):
                for i in range(psi_star_0.shape[0]):
                    for j in range(psi_star_0.shape[1]):
                        updated_psi = uw.function.evalf(
                            self.psi_fn[i, j], self.swarm.data
                        )
                        psi_star_0[i, j].data[:] = updated_psi

        else:
            psi_star_0 = self.psi_star[0]
            with self.swarm.access(psi_star_0):
                for i in range(psi_star_0.shape[0]):
                    for j in range(psi_star_0.shape[1]):
                        updated_psi = uw.function.evaluate(
                            self.psi_fn[i, j], self.swarm.data
                        )
                        psi_star_0[i, j].data[:] = updated_psi

        # Now update the swarm locations

        self.swarm.advection(
            self.V_fn,
            delta_t=dt,
            restore_points_to_domain_func=self.mesh.return_coords_to_bounds,
        )

    def bdf(self, order=None):
        r&#34;&#34;&#34;Backwards differentiation form for calculating DuDt
        Note that you will need `bdf` / $\delta t$ in computing derivatives&#34;&#34;&#34;

        if order is None:
            order = self.order

        with sympy.core.evaluate(True):
            if order == 0:  # special case - no history term (catch )
                bdf0 = sympy.simpify[0]

            if order == 1:
                bdf0 = self.psi_fn - self.psi_star[0].sym

            elif order == 2:
                bdf0 = (
                    3 * self.psi_fn / 2
                    - 2 * self.psi_star[0].sym
                    + self.psi_star[1].sym / 2
                )

            elif order == 3:
                bdf0 = (
                    11 * self.psi_fn / 6
                    - 3 * self.psi_star[0].sym
                    + 3 * self.psi_star[1].sym / 2
                    - self.psi_star[2].sym / 3
                )

        return bdf0

    def adams_moulton_flux(self, order=None):
        if order is None:
            order = self.order

        with sympy.core.evaluate(True):
            if order == 0:  # Special case - no history term
                am = self.psi_fn

            elif order == 1:
                am = (self.psi_fn + self.psi_star[0].sym) / 2

            elif order == 2:
                am = (
                    5 * self.psi_fn + 8 * self.psi_star[0].sym - self.psi_star[1].sym
                ) / 12

            elif order == 3:
                am = (
                    9 * self.psi_fn
                    + 19 * self.psi_star[0].sym
                    - 5 * self.psi_star[1].sym
                    + self.psi_star[2].sym
                ) / 24

        return am</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>underworld3.utilities._api_tools.uw_object</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="underworld3.systems.ddt.Lagrangian.instances"><code class="name">var <span class="ident">instances</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="underworld3.systems.ddt.Lagrangian.adams_moulton_flux"><code class="name flex">
<span>def <span class="ident">adams_moulton_flux</span></span>(<span>self, order=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="underworld3.systems.ddt.Lagrangian.bdf"><code class="name flex">
<span>def <span class="ident">bdf</span></span>(<span>self, order=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Backwards differentiation form for calculating DuDt
Note that you will need <code>bdf</code> / $\delta t$ in computing derivatives</p></div>
</dd>
<dt id="underworld3.systems.ddt.Lagrangian.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, dt: float, evalf: Optional[bool] = False, verbose: Optional[bool] = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="underworld3.systems.ddt.Lagrangian.update_post_solve"><code class="name flex">
<span>def <span class="ident">update_post_solve</span></span>(<span>self, dt: float, evalf: Optional[bool] = False, verbose: Optional[bool] = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="underworld3.systems.ddt.Lagrangian.update_pre_solve"><code class="name flex">
<span>def <span class="ident">update_pre_solve</span></span>(<span>self, dt: float, evalf: Optional[bool] = False, verbose: Optional[bool] = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="underworld3.systems.ddt.Lagrangian_Swarm"><code class="flex name class">
<span>class <span class="ident">Lagrangian_Swarm</span></span>
<span>(</span><span>swarm: <a title="underworld3.swarm.Swarm" href="../swarm.html#underworld3.swarm.Swarm">Swarm</a>, psi_fn: sympy.core.function.Function, vtype: underworld3._var_types.VarType, degree: int, continuous: bool, varsymbol: Optional[str] = 'u', verbose: Optional[bool] = False, bcs=[], order=1, smoothing=0.0, step_averaging=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Swarm-based Lagrangian History Manager:
This manages the update of a Lagrangian variable, $\psi$ on the swarm across timesteps.</p>
<p>$\quad \psi_p^{t-n\Delta t} \leftarrow \psi_p^{t-(n-1)\Delta t}\quad$</p>
<p>$\quad \psi_p^{t-(n-1)\Delta t} \leftarrow \psi_p^{t-(n-2)\Delta t} \cdots\quad$</p>
<p>$\quad \psi_p^{t-\Delta t} \leftarrow \psi_p^{t}$</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lagrangian_Swarm(uw_object):
    r&#34;&#34;&#34;Swarm-based Lagrangian History Manager:
    This manages the update of a Lagrangian variable, $\psi$ on the swarm across timesteps.

    $\quad \psi_p^{t-n\Delta t} \leftarrow \psi_p^{t-(n-1)\Delta t}\quad$

    $\quad \psi_p^{t-(n-1)\Delta t} \leftarrow \psi_p^{t-(n-2)\Delta t} \cdots\quad$

    $\quad \psi_p^{t-\Delta t} \leftarrow \psi_p^{t}$
    &#34;&#34;&#34;

    instances = 0  # count how many of these there are in order to create unique private mesh variable ids

    @timing.routine_timer_decorator
    def __init__(
        self,
        swarm: uw.swarm.Swarm,
        psi_fn: sympy.Function,
        vtype: uw.VarType,
        degree: int,
        continuous: bool,
        varsymbol: Optional[str] = r&#34;u&#34;,
        verbose: Optional[bool] = False,
        bcs=[],
        order=1,
        smoothing=0.0,
        step_averaging=2,
    ):
        super().__init__()

        self.mesh = swarm.mesh
        self.swarm = swarm
        self.psi_fn = psi_fn
        self.verbose = verbose
        self.order = order
        self.step_averaging = step_averaging

        psi_star = []
        self.psi_star = psi_star

        for i in range(order):
            print(f&#34;Creating psi_star[{i}]&#34;)
            self.psi_star.append(
                uw.swarm.SwarmVariable(
                    f&#34;psi_star_sw_{self.instance_number}_{i}&#34;,
                    self.swarm,
                    vtype=vtype,
                    proxy_degree=degree,
                    proxy_continuous=continuous,
                    varsymbol=rf&#34;{varsymbol}^{{ {&#39;*&#39;*(i+1)} }}&#34;,
                )
            )

        return

    def _object_viewer(self):
        from IPython.display import Latex, Markdown, display

        super()._object_viewer()

        ## feedback on this instance
        display(Latex(r&#34;$\quad\psi = $ &#34; + self.psi._repr_latex_()))
        display(
            Latex(
                r&#34;$\quad\Delta t_{\textrm{phys}} = $ &#34;
                + sympy.sympify(self.dt_physical)._repr_latex_()
            )
        )
        display(Latex(rf&#34;$\quad$History steps = {self.order}&#34;))

    ## Note: We may be able to eliminate this
    ## The SL updater and the Lag updater have
    ## different sequencing because of the way they
    ## update the history. It makes more sense for the
    ## full Lagrangian swarm to be updated after the solve
    ## and this means we have to grab the history values first.

    def update(
        self,
        dt: float,
        evalf: Optional[bool] = False,
        verbose: Optional[bool] = False,
    ):
        self.update_post_solve(dt, evalf, verbose)
        return

    def update_pre_solve(
        self,
        dt: float,
        evalf: Optional[bool] = False,
        verbose: Optional[bool] = False,
    ):
        return

    def update_post_solve(
        self,
        dt: float,
        evalf: Optional[bool] = False,
        verbose: Optional[bool] = False,
    ):
        for h in range(self.order - 1):
            i = self.order - (h + 1)

            # copy the information down the chain
            if verbose:
                print(f&#34;Lagrange swarm order = {self.order}&#34;, flush=True)
                print(
                    f&#34;Mesh interpolant order = {self.psi_star[0]._meshVar.degree}&#34;,
                    flush=True,
                )
                print(f&#34;Lagrange swarm copying {i-1} to {i}&#34;, flush=True)

            with self.swarm.access(self.psi_star[i]):
                self.psi_star[i].data[...] = self.psi_star[i - 1].data[...]

        phi = 1 / self.step_averaging

        # Now update the swarm variable
        if evalf:
            psi_star_0 = self.psi_star[0]
            with self.swarm.access(psi_star_0):
                for i in range(psi_star_0.shape[0]):
                    for j in range(psi_star_0.shape[1]):
                        updated_psi = uw.function.evalf(
                            self.psi_fn[i, j], self.swarm.data
                        )
                        psi_star_0[i, j].data[:] = (
                            phi * updated_psi + (1 - phi) * psi_star_0[i, j].data[:]
                        )
        else:
            psi_star_0 = self.psi_star[0]
            with self.swarm.access(psi_star_0):
                for i in range(psi_star_0.shape[0]):
                    for j in range(psi_star_0.shape[1]):
                        updated_psi = uw.function.evaluate(
                            self.psi_fn[i, j], self.swarm.data
                        )
                        psi_star_0[i, j].data[:] = (
                            phi * updated_psi + (1 - phi) * psi_star_0[i, j].data[:]
                        )

        return

    def bdf(self, order=None):
        r&#34;&#34;&#34;Backwards differentiation form for calculating DuDt
        Note that you will need `bdf` / $\delta t$ in computing derivatives&#34;&#34;&#34;

        if order is None:
            order = self.order
        else:
            order = max(1, min(self.order, order))

        with sympy.core.evaluate(False):
            if order &lt;= 1:
                bdf0 = self.psi_fn - self.psi_star[0].sym

            elif order == 2:
                bdf0 = (
                    3 * self.psi_fn / 2
                    - 2 * self.psi_star[0].sym
                    + self.psi_star[1].sym / 2
                )

            elif order == 3:
                bdf0 = (
                    11 * self.psi_fn / 6
                    - 3 * self.psi_star[0].sym
                    + 3 * self.psi_star[1].sym / 2
                    - self.psi_star[2].sym / 3
                )

            bdf0 /= self.step_averaging

        # This is actually calculated over several steps so scaling is required
        return bdf0

    def adams_moulton_flux(self, order=None):
        if order is None:
            order = self.order
        else:
            order = max(1, min(self.order, order))

        with sympy.core.evaluate(False):
            if order == 1:
                am = (self.psi_fn + self.psi_star[0].sym) / 2

            elif order == 2:
                am = (
                    5 * self.psi_fn + 8 * self.psi_star[0].sym - self.psi_star[1].sym
                ) / 12

            elif order == 3:
                am = (
                    9 * self.psi_fn
                    + 19 * self.psi_star[0].sym
                    - 5 * self.psi_star[1].sym
                    + self.psi_star[2].sym
                ) / 24

        return am</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>underworld3.utilities._api_tools.uw_object</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="underworld3.systems.ddt.Lagrangian_Swarm.instances"><code class="name">var <span class="ident">instances</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="underworld3.systems.ddt.Lagrangian_Swarm.adams_moulton_flux"><code class="name flex">
<span>def <span class="ident">adams_moulton_flux</span></span>(<span>self, order=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="underworld3.systems.ddt.Lagrangian_Swarm.bdf"><code class="name flex">
<span>def <span class="ident">bdf</span></span>(<span>self, order=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Backwards differentiation form for calculating DuDt
Note that you will need <code>bdf</code> / $\delta t$ in computing derivatives</p></div>
</dd>
<dt id="underworld3.systems.ddt.Lagrangian_Swarm.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, dt: float, evalf: Optional[bool] = False, verbose: Optional[bool] = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="underworld3.systems.ddt.Lagrangian_Swarm.update_post_solve"><code class="name flex">
<span>def <span class="ident">update_post_solve</span></span>(<span>self, dt: float, evalf: Optional[bool] = False, verbose: Optional[bool] = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="underworld3.systems.ddt.Lagrangian_Swarm.update_pre_solve"><code class="name flex">
<span>def <span class="ident">update_pre_solve</span></span>(<span>self, dt: float, evalf: Optional[bool] = False, verbose: Optional[bool] = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="underworld3.systems.ddt.SemiLagrangian"><code class="flex name class">
<span>class <span class="ident">SemiLagrangian</span></span>
<span>(</span><span>mesh: <a title="underworld3.discretisation.Mesh" href="../discretisation.html#underworld3.discretisation.Mesh">Mesh</a>, psi_fn: sympy.core.function.Function, V_fn: sympy.core.function.Function, vtype: underworld3._var_types.VarType, degree: int, continuous: bool, swarm_degree: Optional[int] = None, swarm_continuous: Optional[bool] = None, varsymbol: Optional[str] = 'u', verbose: Optional[bool] = False, bcs=[], order=1, smoothing=0.0, preserve_moments=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Nodal-Swarm
Lagrangian History Manager:
This manages the update of a Lagrangian variable, $\psi$ on the swarm across timesteps.
<span><span class="MathJax_Preview">\quad \psi_p^{t-n\Delta t} \leftarrow \psi_p^{t-(n-1)\Delta t}\quad</span><script type="math/tex; mode=display">\quad \psi_p^{t-n\Delta t} \leftarrow \psi_p^{t-(n-1)\Delta t}\quad</script></span>
<span><span class="MathJax_Preview">\quad \psi_p^{t-(n-1)\Delta t} \leftarrow \psi_p^{t-(n-2)\Delta t} \cdots\quad</span><script type="math/tex; mode=display">\quad \psi_p^{t-(n-1)\Delta t} \leftarrow \psi_p^{t-(n-2)\Delta t} \cdots\quad</script></span>
<span><span class="MathJax_Preview">\quad \psi_p^{t-\Delta t} \leftarrow \psi_p^{t}</span><script type="math/tex; mode=display">\quad \psi_p^{t-\Delta t} \leftarrow \psi_p^{t}</script></span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SemiLagrangian(uw_object):
    r&#34;&#34;&#34;Nodal-Swarm  Lagrangian History Manager:
    This manages the update of a Lagrangian variable, $\psi$ on the swarm across timesteps.
    $$\quad \psi_p^{t-n\Delta t} \leftarrow \psi_p^{t-(n-1)\Delta t}\quad$$
    $$\quad \psi_p^{t-(n-1)\Delta t} \leftarrow \psi_p^{t-(n-2)\Delta t} \cdots\quad$$
    $$\quad \psi_p^{t-\Delta t} \leftarrow \psi_p^{t}$$
    &#34;&#34;&#34;

    @timing.routine_timer_decorator
    def __init__(
        self,
        mesh: uw.discretisation.Mesh,
        psi_fn: sympy.Function,
        V_fn: sympy.Function,
        vtype: uw.VarType,
        degree: int,
        continuous: bool,
        swarm_degree: Optional[int] = None,
        swarm_continuous: Optional[bool] = None,
        varsymbol: Optional[str] = r&#34;u&#34;,
        verbose: Optional[bool] = False,
        bcs=[],
        order=1,
        smoothing=0.0,
        preserve_moments=False,
    ):
        super().__init__()

        self.mesh = mesh
        self.bcs = bcs
        self.verbose = verbose
        self.degree = degree
        self.continuous = continuous
        self._psi_fn = psi_fn
        self.V_fn = V_fn
        self.order = order
        self.preserve_moments = preserve_moments

        if swarm_degree is None:
            self.swarm_degree = degree
        else:
            self.swarm_degree = swarm_degree

        if swarm_continuous is None:
            self.swarm_continuous = continuous
        else:
            self.swarm_continuous = swarm_continuous

        # meshVariables are required for:
        #
        # u(t) - evaluation of u_fn at the current time
        # u*(t) - u_* evaluated from

        # psi is evaluated/stored at `order` timesteps. We can&#39;t
        # be sure if psi is a meshVariable or a function to be evaluated
        # but psi_star is reaching back through each evaluation and has to be a
        # meshVariable (storage)

        psi_star = []
        self.psi_star = psi_star

        for i in range(order):
            self.psi_star.append(
                uw.discretisation.MeshVariable(
                    f&#34;psi_star_sl_{self.instance_number}_{i}&#34;,
                    self.mesh,
                    vtype=vtype,
                    degree=self.degree,
                    continuous=self.continuous,
                    varsymbol=rf&#34;{{ {varsymbol}^{{ {&#39;*&#39;*(i+1)} }} }}&#34;,
                )
            )

        # Working variable that has a potentially different discretisation from psi_star
        # We project from this to psi_star and we use this variable to define the
        # advection sample points

        self._workVar = uw.discretisation.MeshVariable(
            f&#34;W_{self.instance_number}_{i}&#34;,
            self.mesh,
            vtype=vtype,
            degree=self.swarm_degree,
            continuous=self.swarm_continuous,
            varsymbol=rf&#34;{{ {varsymbol}^\nabla }}&#34;,
        )

        # We just need one swarm since this is inherently a sequential operation
        nswarm = uw.swarm.NodalPointSwarm(self._workVar, verbose)
        self._nswarm_psi = nswarm

        # The projection operator for mapping swarm values to the mesh - needs to be different for
        # each variable type, unfortunately ...

        if vtype == uw.VarType.SCALAR:
            self._psi_star_projection_solver = uw.systems.solvers.SNES_Projection(
                self.mesh, self.psi_star[0], verbose=False
            )
        elif vtype == uw.VarType.VECTOR:
            self._psi_star_projection_solver = (
                uw.systems.solvers.SNES_Vector_Projection(
                    self.mesh,
                    self.psi_star[0],
                    verbose=False,
                )
            )

        elif vtype == uw.VarType.SYM_TENSOR or vtype == uw.VarType.TENSOR:
            self._WorkVarTP = uw.discretisation.MeshVariable(
                f&#34;W_star_slcn_{self.instance_number}&#34;,
                self.mesh,
                vtype=uw.VarType.SCALAR,
                degree=degree,
                continuous=continuous,
                varsymbol=r&#34;W^{*}&#34;,
            )
            self._psi_star_projection_solver = (
                uw.systems.solvers.SNES_Tensor_Projection(
                    self.mesh, self.psi_star[0], self._WorkVarTP, verbose=False
                )
            )

        # We should find a way to add natural bcs here
        # (self.Unknowns.u carried as a symbol from solver to solver)

        self._psi_star_projection_solver.uw_function = self._workVar.sym
        self._psi_star_projection_solver.bcs = bcs
        self._psi_star_projection_solver.smoothing = smoothing

        self._smoothing = smoothing

        self.I = uw.maths.Integral(mesh, None)

        return

    @property
    def psi_fn(self):
        return self._psi_fn

    @psi_fn.setter
    def psi_fn(self, new_fn):
        self._psi_fn = new_fn
        self._psi_star_projection_solver.uw_function = self._psi_fn
        return

    def _object_viewer(self):
        from IPython.display import Latex, Markdown, display

        super()._object_viewer()

        display(Latex(rf&#34;$\quad$History steps = {self.order}&#34;))

    def update(
        self,
        dt: float,
        evalf: Optional[bool] = False,
        verbose: Optional[bool] = False,
        dt_physical: Optional = None,
    ):
        self.update_pre_solve(dt, evalf, verbose, dt_physical)
        return

    def update_post_solve(
        self,
        dt: float,
        evalf: Optional[bool] = False,
        verbose: Optional[bool] = False,
        dt_physical: Optional[float] = None,
    ):
        return

    def update_pre_solve(
        self,
        dt: float,
        evalf: Optional[bool] = False,
        verbose: Optional[bool] = False,
        dt_physical: Optional[float] = None,
    ):

        ## Progress from the oldest part of the history
        # 1. Copy the stored values down the chain

        if dt_physical is not None:
            phi = min(1, dt / dt_physical)
        else:
            phi = sympy.sympify(1)

        for i in range(self.order - 1, 0, -1):
            with self.mesh.access(self.psi_star[i]):
                self.psi_star[i].data[...] = (
                    phi * self.psi_star[i - 1].data[...]
                    + (1 - phi) * self.psi_star[i].data[...]
                )

        # 2. Compute the upstream values from the psi_fn

        # We use the u_star variable as a working value here so we have to work backwards
        # so we don&#39;t over-write the history terms
        #

        for i in range(self.order - 1, -1, -1):
            with self._nswarm_psi.access(self._nswarm_psi._X0):
                self._nswarm_psi._X0.data[...] = self._nswarm_psi.data[...]

            # march nodes backwards along characteristics
            self._nswarm_psi.advection(
                self.V_fn,
                -dt,
                order=1,
                corrector=False,
                restore_points_to_domain_func=self.mesh.return_coords_to_bounds,
                evalf=False,
                step_limit=True,
                #! substepping: this seems to be too diffusive if left on.
                #! Check the code carefully !
            )

            if i == 0:
                # Recalculate psi_star from psi_fn. If psi_fn containts
                # derivatives, the evaluation will fail and a projection
                # is required instead.

                try:
                    # Note, we should honour the evalf flag here too.
                    with self._workVar.mesh.access():
                        self.psi_star[0].data[...] = uw.function.evaluate(
                            self.psi_fn, self.psi_star[0].coords
                        )
                except:
                    self._psi_star_projection_solver.uw_function = self.psi_fn
                    self._psi_star_projection_solver.smoothing = 0.0
                    self._psi_star_projection_solver.solve(verbose=verbose)

            if evalf:
                with self._nswarm_psi.access(self._nswarm_psi.swarmVariable):
                    for d in range(self.psi_star[i].shape[1]):
                        self._nswarm_psi.swarmVariable.data[:, d] = uw.function.evalf(
                            self.psi_star[i].sym[d], self._nswarm_psi.data
                        )
            else:
                with self._nswarm_psi.access(self._nswarm_psi.swarmVariable):
                    for d in range(self.psi_star[i].shape[1]):
                        self._nswarm_psi.swarmVariable.data[
                            :, d
                        ] = uw.function.evaluate(
                            self.psi_star[i].sym[d], self._nswarm_psi.data
                        )

            if self.preserve_moments and self._workVar.num_components == 1:

                self.I.fn = self.psi_star[i].sym[0]
                Imean0 = self.I.evaluate()

                self.I.fn = (self.psi_star[i].sym[0] - Imean0) ** 2
                IL20 = np.sqrt(self.I.evaluate())

                # if uw.mpi.rank == 0:
                #     print(f&#34;Pre advection:  {Imean0}, {IL20}&#34;, flush=True)

            # restore coords (will call dm.migrate after context manager releases)
            # We need some modifications to dm.migrate to snapback
            # to original location without substepping

            og_mig_type = uw.function.dm_swarm_get_migrate_type(
                self._nswarm_psi
            )  # get original migrate type
            uw.function.dm_swarm_set_migrate_type(
                self._nswarm_psi, PETSc.DMSwarm.MigrateType.MIGRATE_BASIC
            )

            # change the rank in DMSwarm_rank with the rank before advection
            nR0_field_name = self._nswarm_psi._nR0.name
            nI0_field_name = self._nswarm_psi._nI0.name

            orig_ranks = self._nswarm_psi.dm.getField(nR0_field_name)
            node_ranks = self._nswarm_psi.dm.getField(&#34;DMSwarm_rank&#34;)

            node_ranks[...] = orig_ranks[...]

            self._nswarm_psi.dm.restoreField(nR0_field_name)
            self._nswarm_psi.dm.restoreField(&#34;DMSwarm_rank&#34;)

            # will update DMSwarm_cellid, DMSwarmPIC_cooor, etc and call migrate

            with self._nswarm_psi.access(self._nswarm_psi.particle_coordinates):
                self._nswarm_psi.data[...] = self._nswarm_psi._nX0.data[...]

            # reset to original migrate type
            uw.function.dm_swarm_set_migrate_type(self._nswarm_psi, og_mig_type)

            # Push data from swarm back to _workVar.data.
            # Note: particles are removed when sent and added to the
            # end of the swarm when received, so we need to re-order
            # the data when we put it back onto the nodes

            with self._nswarm_psi.access():

                orig_index = self._nswarm_psi._nI0.data.copy().reshape(-1)

                with self.mesh.access(self._workVar):
                    self._workVar.data[
                        orig_index, :
                    ] = self._nswarm_psi.swarmVariable.data[:, :]

            # Project / Copy from advected swarm to semi-Lagrangian variables.

            if self._workVar.coords.shape == self.psi_star[i].coords.shape:
                with self.mesh.access(self.psi_star[i]):
                    self.psi_star[i].data[...] = self._workVar.data[...]
            else:
                self._psi_star_projection_solver.uw_function = self._workVar.sym
                self._psi_star_projection_solver.smoothing = 0.0
                self._psi_star_projection_solver.solve()

            # Copy data from the projection operator if i!=0
            if i != 0:
                with self.mesh.access(self.psi_star[i]):
                    self.psi_star[i].data[...] = self.psi_star[0].data[...]

            # Optional: Conserve moments for scalar fields
            # (could extend this to other field types but not
            #  sure if this is wanted / warranted at all )

            if self.preserve_moments and self._workVar.num_components == 1:

                self.I.fn = self.psi_star[i].sym[0]
                Imean = self.I.evaluate()

                self.I.fn = (self.psi_star[i].sym[0] - Imean) ** 2
                IL2 = np.sqrt(self.I.evaluate())

                # if uw.mpi.rank == 0:
                #     print(f&#34;Pre adjustment: {Imean}, {IL2}&#34;, flush=True)

                with self.mesh.access(self.psi_star[i]):
                    self.psi_star[i].data[...] += Imean0 - Imean

                self.I.fn = (self.psi_star[i].sym[0] - Imean0) ** 2
                IL2 = np.sqrt(self.I.evaluate())

                with self.mesh.access(self.psi_star[i]):
                    self.psi_star[i].data[...] = (
                        self.psi_star[i].data[...] - Imean0
                    ) * IL20 / IL2 + Imean0

                # self.I.fn = self.psi_star[i].sym[0]
                # Imean = self.I.evaluate()

                # self.I.fn = (self.psi_star[0].sym[0] - Imean) ** 2
                # IL2 = np.sqrt(self.I.evaluate())

                # if uw.mpi.rank == 0:
                #     print(f&#34;Post advection: {Imean}, {IL2}&#34;, flush=True)

        return

    def bdf(self, order=None):
        r&#34;&#34;&#34;Backwards differentiation form for calculating DuDt
        Note that you will need `bdf` / $\delta t$ in computing derivatives&#34;&#34;&#34;

        if order is None:
            order = self.order
        else:
            order = max(1, min(self.order, order))

        with sympy.core.evaluate(True):
            if order == 1:
                bdf0 = self.psi_fn - self.psi_star[0].sym

            elif order == 2:
                bdf0 = (
                    3 * self.psi_fn / 2
                    - 2 * self.psi_star[0].sym
                    + self.psi_star[1].sym / 2
                )

            elif order == 3:
                bdf0 = (
                    11 * self.psi_fn / 6
                    - 3 * self.psi_star[0].sym
                    + 3 * self.psi_star[1].sym / 2
                    - self.psi_star[2].sym / 3
                )

        return bdf0

    def adams_moulton_flux(self, order=None):
        if order is None:
            order = self.order
        else:
            order = max(0, min(self.order, order))

        with sympy.core.evaluate(True):

            if order == 0:
                am = self.psi_fn

            elif order == 1:
                am = (self.psi_fn + self.psi_star[0].sym) / 2

            elif order == 2:
                am = (
                    5 * self.psi_fn + 8 * self.psi_star[0].sym - self.psi_star[1].sym
                ) / 12

            elif order == 3:
                am = (
                    9 * self.psi_fn
                    + 19 * self.psi_star[0].sym
                    - 5 * self.psi_star[1].sym
                    + self.psi_star[2].sym
                ) / 24

        return am</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>underworld3.utilities._api_tools.uw_object</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="underworld3.systems.ddt.SemiLagrangian.psi_fn"><code class="name">prop <span class="ident">psi_fn</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def psi_fn(self):
    return self._psi_fn</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="underworld3.systems.ddt.SemiLagrangian.adams_moulton_flux"><code class="name flex">
<span>def <span class="ident">adams_moulton_flux</span></span>(<span>self, order=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="underworld3.systems.ddt.SemiLagrangian.bdf"><code class="name flex">
<span>def <span class="ident">bdf</span></span>(<span>self, order=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Backwards differentiation form for calculating DuDt
Note that you will need <code>bdf</code> / $\delta t$ in computing derivatives</p></div>
</dd>
<dt id="underworld3.systems.ddt.SemiLagrangian.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, dt: float, evalf: Optional[bool] = False, verbose: Optional[bool] = False, dt_physical: Optional = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="underworld3.systems.ddt.SemiLagrangian.update_post_solve"><code class="name flex">
<span>def <span class="ident">update_post_solve</span></span>(<span>self, dt: float, evalf: Optional[bool] = False, verbose: Optional[bool] = False, dt_physical: Optional[float] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="underworld3.systems.ddt.SemiLagrangian.update_pre_solve"><code class="name flex">
<span>def <span class="ident">update_pre_solve</span></span>(<span>self, dt: float, evalf: Optional[bool] = False, verbose: Optional[bool] = False, dt_physical: Optional[float] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="underworld3.systems" href="index.html">underworld3.systems</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="underworld3.systems.ddt.Lagrangian" href="#underworld3.systems.ddt.Lagrangian">Lagrangian</a></code></h4>
<ul class="two-column">
<li><code><a title="underworld3.systems.ddt.Lagrangian.adams_moulton_flux" href="#underworld3.systems.ddt.Lagrangian.adams_moulton_flux">adams_moulton_flux</a></code></li>
<li><code><a title="underworld3.systems.ddt.Lagrangian.bdf" href="#underworld3.systems.ddt.Lagrangian.bdf">bdf</a></code></li>
<li><code><a title="underworld3.systems.ddt.Lagrangian.instances" href="#underworld3.systems.ddt.Lagrangian.instances">instances</a></code></li>
<li><code><a title="underworld3.systems.ddt.Lagrangian.update" href="#underworld3.systems.ddt.Lagrangian.update">update</a></code></li>
<li><code><a title="underworld3.systems.ddt.Lagrangian.update_post_solve" href="#underworld3.systems.ddt.Lagrangian.update_post_solve">update_post_solve</a></code></li>
<li><code><a title="underworld3.systems.ddt.Lagrangian.update_pre_solve" href="#underworld3.systems.ddt.Lagrangian.update_pre_solve">update_pre_solve</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="underworld3.systems.ddt.Lagrangian_Swarm" href="#underworld3.systems.ddt.Lagrangian_Swarm">Lagrangian_Swarm</a></code></h4>
<ul class="two-column">
<li><code><a title="underworld3.systems.ddt.Lagrangian_Swarm.adams_moulton_flux" href="#underworld3.systems.ddt.Lagrangian_Swarm.adams_moulton_flux">adams_moulton_flux</a></code></li>
<li><code><a title="underworld3.systems.ddt.Lagrangian_Swarm.bdf" href="#underworld3.systems.ddt.Lagrangian_Swarm.bdf">bdf</a></code></li>
<li><code><a title="underworld3.systems.ddt.Lagrangian_Swarm.instances" href="#underworld3.systems.ddt.Lagrangian_Swarm.instances">instances</a></code></li>
<li><code><a title="underworld3.systems.ddt.Lagrangian_Swarm.update" href="#underworld3.systems.ddt.Lagrangian_Swarm.update">update</a></code></li>
<li><code><a title="underworld3.systems.ddt.Lagrangian_Swarm.update_post_solve" href="#underworld3.systems.ddt.Lagrangian_Swarm.update_post_solve">update_post_solve</a></code></li>
<li><code><a title="underworld3.systems.ddt.Lagrangian_Swarm.update_pre_solve" href="#underworld3.systems.ddt.Lagrangian_Swarm.update_pre_solve">update_pre_solve</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="underworld3.systems.ddt.SemiLagrangian" href="#underworld3.systems.ddt.SemiLagrangian">SemiLagrangian</a></code></h4>
<ul class="two-column">
<li><code><a title="underworld3.systems.ddt.SemiLagrangian.adams_moulton_flux" href="#underworld3.systems.ddt.SemiLagrangian.adams_moulton_flux">adams_moulton_flux</a></code></li>
<li><code><a title="underworld3.systems.ddt.SemiLagrangian.bdf" href="#underworld3.systems.ddt.SemiLagrangian.bdf">bdf</a></code></li>
<li><code><a title="underworld3.systems.ddt.SemiLagrangian.psi_fn" href="#underworld3.systems.ddt.SemiLagrangian.psi_fn">psi_fn</a></code></li>
<li><code><a title="underworld3.systems.ddt.SemiLagrangian.update" href="#underworld3.systems.ddt.SemiLagrangian.update">update</a></code></li>
<li><code><a title="underworld3.systems.ddt.SemiLagrangian.update_post_solve" href="#underworld3.systems.ddt.SemiLagrangian.update_post_solve">update_post_solve</a></code></li>
<li><code><a title="underworld3.systems.ddt.SemiLagrangian.update_pre_solve" href="#underworld3.systems.ddt.SemiLagrangian.update_pre_solve">update_pre_solve</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
