<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>underworld3.discretisation API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>underworld3.discretisation</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="underworld3.discretisation.MeshVariable"><code class="name flex">
<span>def <span class="ident">MeshVariable</span></span>(<span>varname: Union[str, list], mesh: <a title="underworld3.discretisation.Mesh" href="#underworld3.discretisation.Mesh">Mesh</a>, num_components: Union[int, tuple] = None, vtype: Optional[ForwardRef('uw.VarType')] = None, degree: int = 1, continuous: bool = True, varsymbol: Union[str, list] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>The MeshVariable class generates a variable supported by a finite element mesh and the
underlying sympy representation that makes it possible to construct expressions that
depend on the values of the MeshVariable.</p>
<p>To set / read nodal values, use the numpy interface via the 'data' property.</p>
<h2 id="parameters">Parameters</h2>
<p>varname :
A text name for this variable. Use an R-string if a latex-expression is used
mesh :
The supporting underworld mesh.
num_components :
The number of components this variable has.
For example, scalars will have <code>num_components=1</code>,
while a 2d vector would have <code>num_components=2</code>.
vtype :
Optional. The underworld variable type for this variable.
If not defined it will be inferred from <code>num_components</code>
if possible.
degree :
The polynomial degree for this variable.
varsymbol:
Over-ride the varname with a symbolic form for printing etc (latex). Should be an R-string.</p></div>
</dd>
<dt id="underworld3.discretisation.checkpoint_xdmf"><code class="name flex">
<span>def <span class="ident">checkpoint_xdmf</span></span>(<span>filename: str, meshUpdates: bool = True, meshVars: Optional[list] = [], swarmVars: Optional[list] = [], index: Optional[int] = 0)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="underworld3.discretisation.meshVariable_lookup_by_symbol"><code class="name flex">
<span>def <span class="ident">meshVariable_lookup_by_symbol</span></span>(<span>mesh, sympy_object)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a sympy object, scan the mesh variables in <code>mesh</code> to find the
location (meshvariable, component in the data array) corresponding to the symbol
or return None if not found</p></div>
</dd>
<dt id="underworld3.discretisation.petsc_dm_find_labeled_points_local"><code class="name flex">
<span>def <span class="ident">petsc_dm_find_labeled_points_local</span></span>(<span>dm, label_name, label_value, sectionIndex=False, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Identify local points associated with "Label"</p>
<p>dm -&gt; expects a petscDM object
label_name -&gt; "String Name for Label"
sectionIndex -&gt; False: leave points as indexed by the relevant section on the dm
True: index into the local coordinate array</p>
<p>NOTE: Assumes uniform element types</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="underworld3.discretisation.Mesh"><code class="flex name class">
<span>class <span class="ident">Mesh</span></span>
<span>(</span><span>plex_or_meshfile, degree=1, simplex=True, coordinate_system_type=None, qdegree=2, markVertices=None, useRegions=None, useMultipleTags=None, filename=None, refinement=None, refinement_callback=None, return_coords_to_bounds=None, boundaries=None, boundary_normals=None, name=None, verbose=False, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Mesh class for uw - documentation needed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mesh(Stateful, uw_object):
    r&#34;&#34;&#34;
    Mesh class for uw - documentation needed
    &#34;&#34;&#34;

    mesh_instances = 0

    @timing.routine_timer_decorator
    def __init__(
        self,
        plex_or_meshfile,
        degree=1,
        simplex=True,
        coordinate_system_type=None,
        qdegree=2,
        markVertices=None,
        useRegions=None,
        useMultipleTags=None,
        filename=None,
        refinement=None,
        refinement_callback=None,
        return_coords_to_bounds=None,
        boundaries=None,
        boundary_normals=None,
        name=None,
        verbose=False,
        *args,
        **kwargs,
    ):
        self.instance = Mesh.mesh_instances
        Mesh.mesh_instances += 1

        comm = PETSc.COMM_WORLD

        if isinstance(plex_or_meshfile, PETSc.DMPlex):
            if verbose and uw.mpi.rank == 0:
                print(f&#34;Constructing UW mesh from DMPlex object&#34;, flush=True)
            name = &#34;plexmesh&#34;
            self.dm = plex_or_meshfile
            self.sf0 = None  # Should we build one ?
        else:
            comm = kwargs.get(&#34;comm&#34;, PETSc.COMM_WORLD)
            name = plex_or_meshfile
            basename, ext = os.path.splitext(plex_or_meshfile)

            # Note: should be able to handle a .geo as well on this pathway
            if ext.lower() == &#34;.msh&#34;:
                if verbose and uw.mpi.rank == 0:
                    print(
                        f&#34;Constructing UW mesh from gmsh {plex_or_meshfile}&#34;, flush=True
                    )

                self.sf0, self.dm = _from_gmsh(
                    plex_or_meshfile,
                    comm,
                    markVertices=markVertices,
                    useRegions=useRegions,
                    useMultipleTags=useMultipleTags,
                )
            elif ext.lower() == &#34;.h5&#34;:
                if verbose and uw.mpi.rank == 0:
                    print(
                        f&#34;Constructing UW mesh from DMPlex h5 file {plex_or_meshfile}&#34;,
                        flush=True,
                    )
                self.sf0, self.dm = _from_plexh5(
                    plex_or_meshfile, PETSc.COMM_WORLD, return_sf=True
                )

            else:
                raise RuntimeError(
                    &#34;Mesh file %s has unknown format &#39;%s&#39;.&#34;
                    % (plex_or_meshfile, ext[1:])
                )

        self.filename = filename
        self.boundaries = boundaries
        self.boundary_normals = boundary_normals

        # options.delValue(&#34;dm_plex_gmsh_mark_vertices&#34;)
        # options.delValue(&#34;dm_plex_gmsh_multiple_tags&#34;)
        # options.delValue(&#34;dm_plex_gmsh_use_regions&#34;)
        self.dm.setFromOptions()

        # uw.adaptivity._dm_stack_bcs(self.dm, self.boundaries, &#34;UW_Boundaries&#34;)

        # all_edges_label_dm = self.dm.getLabel(&#34;depth&#34;)
        # if all_edges_label_dm:
        #     all_edges_IS_dm = all_edges_label_dm.getStratumIS(1)
        #     # all_edges_IS_dm.view()

        # self.dm.createLabel(&#34;All_Edges&#34;)
        # all_edges_label = self.dm.getLabel(&#34;All_Edges&#34;)
        # if all_edges_label and all_edges_IS_dm:
        #     all_edges_label.setStratumIS(boundaries.All_Edges.value, all_edges_IS_dm)

        ## --- UW_Boundaries label
        if self.boundaries is not None:

            self.dm.removeLabel(&#34;UW_Boundaries&#34;)
            uw.mpi.barrier()
            self.dm.createLabel(&#34;UW_Boundaries&#34;)

            stacked_bc_label = self.dm.getLabel(&#34;UW_Boundaries&#34;)

            for b in self.boundaries:
                bc_label_name = b.name
                label = self.dm.getLabel(bc_label_name)

                if label:
                    label_is = label.getStratumIS(b.value)

                    # Load this up on the stacked BC label
                    if label_is:
                        stacked_bc_label.setStratumIS(b.value, label_is)

            uw.mpi.barrier()

        ## ---

        self.refinement_callback = refinement_callback
        self.name = name
        self.sf1 = None
        self.return_coords_to_bounds = return_coords_to_bounds

        ## This is where we can refine the dm if required, and rebuild / redistribute

        if verbose and uw.mpi.rank == 0:
            print(
                f&#34;Mesh refinement levels: {refinement}&#34;,
                flush=True,
            )

        uw.mpi.barrier()

        if not refinement is None and refinement &gt; 0:

            self.dm.setRefinementUniform()

            if not self.dm.isDistributed():
                self.dm.distribute()

            # self.dm_hierarchy = self.dm.refineHierarchy(refinement)

            # This is preferable to the refineHierarchy call
            # because we can repair the refined mesh at each
            # step along the way

            self.dm_hierarchy = [self.dm]
            for i in range(refinement):
                dm_refined = self.dm_hierarchy[i].refine()
                dm_refined.setCoarseDM(self.dm_hierarchy[i])

                if callable(refinement_callback):
                    refinement_callback(dm_refined)

                self.dm_hierarchy.append(dm_refined)

            # self.dm_hierarchy = [self.dm] + self.dm_hierarchy

            self.dm_h = self.dm_hierarchy[-1]
            self.dm_h.setName(&#34;uw_hierarchical_dm&#34;)

            if callable(refinement_callback):
                for dm in self.dm_hierarchy:
                    refinement_callback(dm)

            # Single level equivalent dm (needed for aux vars ?? Check this - LM)
            self.dm = self.dm_h.clone()

        else:
            if not self.dm.isDistributed():
                self.dm.distribute()

            self.dm_hierarchy = [self.dm]
            self.dm_h = self.dm.clone()

        # This will be done anyway - the mesh maybe in a
        # partially adapted state

        if self.sf1 and self.sf0:
            self.sf = self.sf0.compose(self.sf1)
        else:
            self.sf = self.sf0  # could be None !

        if self.name is None:
            self.name = &#34;mesh&#34;
            self.dm.setName(&#34;uw_mesh&#34;)
        else:
            self.dm.setName(f&#34;uw_{self.name}&#34;)

        # Set sympy constructs. First a generic, symbolic, Cartesian coordinate system
        # A unique set of vectors / names for each mesh instance

        from sympy.vector import CoordSys3D

        self._N = CoordSys3D(f&#34;N&#34;)

        # Tidy some of this printing without changing the
        # underlying vector names (as these are part of the code generation system)

        self._N.x._latex_form = r&#34;\mathrm{\xi_0}&#34;
        self._N.y._latex_form = r&#34;\mathrm{\xi_1}&#34;
        self._N.z._latex_form = r&#34;\mathrm{\xi_2}&#34;
        self._N.i._latex_form = r&#34;\mathbf{\hat{\mathbf{e}}_0}&#34;
        self._N.j._latex_form = r&#34;\mathbf{\hat{\mathbf{e}}_1}&#34;
        self._N.k._latex_form = r&#34;\mathbf{\hat{\mathbf{e}}_2}&#34;

        self._Gamma = CoordSys3D(r&#34;\Gamma&#34;)

        self._Gamma.x._latex_form = r&#34;\Gamma_x&#34;
        self._Gamma.y._latex_form = r&#34;\Gamma_y&#34;
        self._Gamma.z._latex_form = r&#34;\Gamma_z&#34;

        # Now add the appropriate coordinate system for the mesh&#39;s natural geometry
        # This step will usually over-write the defaults we just defined
        self._CoordinateSystem = CoordinateSystem(self, coordinate_system_type)

        # This was in the _jit extension but ... if
        # not here then the tests fail sometimes (caching ?)

        self._N.x._ccodestr = &#34;petsc_x[0]&#34;
        self._N.y._ccodestr = &#34;petsc_x[1]&#34;
        self._N.z._ccodestr = &#34;petsc_x[2]&#34;

        # Surface integrals also have normal vector information as petsc_n

        self._Gamma.x._ccodestr = &#34;petsc_n[0]&#34;
        self._Gamma.y._ccodestr = &#34;petsc_n[1]&#34;
        self._Gamma.z._ccodestr = &#34;petsc_n[2]&#34;

        try:
            self.isSimplex = self.dm.isSimplex()
        except:
            self.isSimplex = simplex

        self._vars = {}
        self._block_vars = {}

        # a list of equation systems that will
        # need to be rebuilt if the mesh coordinates change

        self._equation_systems_register = []

        self._evaluation_hash = None
        self._evaluation_interpolated_results = None
        self._accessed = False
        self._quadrature = False
        self._stale_lvec = True
        self._lvec = None
        self.petsc_fe = None

        self.degree = degree
        self.qdegree = qdegree

        self.nuke_coords_and_rebuild()

        if verbose and uw.mpi.rank == 0:
            print(
                f&#34;Populating mesh coordinates {coordinate_system_type}&#34;,
                flush=True,
            )

        ## Coordinate System

        if (
            self.CoordinateSystem.coordinate_type
            == CoordinateSystemType.CYLINDRICAL2D_NATIVE
            or self.CoordinateSystem.coordinate_type
            == CoordinateSystemType.CYLINDRICAL3D_NATIVE
        ):
            self.vector = uw.maths.vector_calculus_cylindrical(
                mesh=self,
            )
        elif (
            self.CoordinateSystem.coordinate_type
            == CoordinateSystemType.SPHERICAL_NATIVE
        ):
            self.vector = uw.maths.vector_calculus_spherical(
                mesh=self,
            )  ## Not yet complete or tested

        elif (
            self.CoordinateSystem.coordinate_type
            == CoordinateSystemType.SPHERE_SURFACE_NATIVE
        ):
            self.vector = uw.maths.vector_calculus_spherical_surface2D_lonlat(
                mesh=self,
            )

        else:
            self.vector = uw.maths.vector_calculus(mesh=self)

        super().__init__()

    @property
    def dim(self) -&gt; int:
        &#34;&#34;&#34;
        The mesh dimensionality.
        &#34;&#34;&#34;
        return self.dm.getDimension()

    @property
    def cdim(self) -&gt; int:
        &#34;&#34;&#34;
        The mesh dimensionality.
        &#34;&#34;&#34;
        return self.dm.getCoordinateDim()

    def view(self):

        import numpy as np

        if uw.mpi.rank == 0:
            print(f&#34;\n&#34;)
            print(f&#34;Mesh # {self.instance}: {self.name}\n&#34;)

            if len(self.vars) &gt; 0:
                print(f&#34;| Variable Name       | component | degree |     type        |&#34;)
                print(f&#34;| ---------------------------------------------------------- |&#34;)
                for vname in self.vars.keys():
                    v = self.vars[vname]
                    print(
                        f&#34;| {v.clean_name:&lt;20}|{v.num_components:^10} |{v.degree:^7} | {v.vtype.name:^15} |&#34;
                    )

                print(f&#34;| ---------------------------------------------------------- |&#34;)
                print(&#34;\n&#34;, flush=True)
            else:
                print(f&#34;No variables are defined on the mesh\n&#34;, flush=True)

        ## Boundary information

        if uw.mpi.rank == 0:
            if len(self.boundaries) &gt; 0:
                print(
                    f&#34;| Boundary Name            | ID    | Min Size | Max Size |&#34;,
                    flush=True,
                )
                print(
                    f&#34;| ------------------------------------------------------ |&#34;,
                    flush=True,
                )
            else:
                print(f&#34;No boundary labels are defined on the mesh\n&#34;, flush=True)

        for bd in self.boundaries:
            l = self.dm.getLabel(bd.name)
            if l:
                i = l.getStratumSize(bd.value)
            else:
                i = 0

            ii = uw.utilities.gather_data(np.array([i]), dtype=&#34;int&#34;)

            if uw.mpi.rank == 0:
                print(
                    f&#34;| {bd.name:&lt;20}     | {bd.value:&lt;5} | {ii.min():&lt;8} | {ii.max():&lt;8} |&#34;,
                    flush=True,
                )

        ## PETSc marked boundaries:
        l = self.dm.getLabel(&#34;All_Boundaries&#34;)
        if l:
            i = l.getStratumSize(1001)
        else:
            i = 0

        ii = uw.utilities.gather_data(np.array([i]), dtype=&#34;int&#34;)

        if uw.mpi.rank == 0:
            print(
                f&#34;| {&#39;All_Boundaries&#39;:&lt;20}     | 1001  | {ii.min():&lt;8} | {ii.max():&lt;8} |&#34;,
                flush=True,
            )

        ## UW_Boundaries:
        l = self.dm.getLabel(&#34;UW_Boundaries&#34;)
        i = 0
        if l:
            for bd in self.boundaries:
                i += l.getStratumSize(bd.value)

        ii = uw.utilities.gather_data(np.array([i]), dtype=&#34;int&#34;)

        if uw.mpi.rank == 0:
            print(
                f&#34;| {&#39;UW_Boundaries&#39;:&lt;20}     | --    | {ii.min():&lt;8} | {ii.max():&lt;8} |&#34;,
                flush=True,
            )

        if uw.mpi.rank == 0:
            print(f&#34;| ------------------------------------------------------ |&#34;)
            print(&#34;\n&#34;, flush=True)

        ## Information on the mesh DM
        self.dm.view()

    def view_parallel(self):
        &#34;&#34;&#34;
        returns the break down of boundary labels from each processor
        &#34;&#34;&#34;

        import numpy as np

        if uw.mpi.rank == 0:
            print(f&#34;\n&#34;)
            print(f&#34;Mesh # {self.instance}: {self.name}\n&#34;)

            if len(self.vars) &gt; 0:
                print(f&#34;| Variable Name       | component | degree |     type        |&#34;)
                print(f&#34;| ---------------------------------------------------------- |&#34;)
                for vname in self.vars.keys():
                    v = self.vars[vname]
                    print(
                        f&#34;| {v.clean_name:&lt;20}|{v.num_components:^10} |{v.degree:^7} | {v.vtype.name:^15} |&#34;
                    )

                print(f&#34;| ---------------------------------------------------------- |&#34;)
                print(&#34;\n&#34;, flush=True)
            else:
                print(f&#34;No variables are defined on the mesh\n&#34;, flush=True)

        ## Boundary information on each proc

        if uw.mpi.rank == 0:
            if len(self.boundaries) &gt; 0:
                print(f&#34;| Boundary Name            | ID    | Size | Proc ID      |&#34;)
                print(f&#34;| ------------------------------------------------------ |&#34;)
            else:
                print(f&#34;No boundary labels are defined on the mesh\n&#34;)

        ### goes through each processor and gets the label size
        with uw.mpi.call_pattern(pattern=&#34;sequential&#34;):
            for bd in self.boundaries:
                l = self.dm.getLabel(bd.name)
                if l:
                    i = l.getStratumSize(bd.value)
                else:
                    i = 0
                print(
                    f&#34;| {bd.name:&lt;20}     | {bd.value:&lt;5} | {i:&lt;8} | {uw.mpi.rank:&lt;8} |&#34;
                )

        uw.mpi.barrier()

        if uw.mpi.rank == 0:
            print(f&#34;| ------------------------------------------------------ |&#34;)
            print(&#34;\n&#34;, flush=True)

        ## Information on the mesh DM
        # self.dm.view()

    # This only works for local - we can&#39;t access global information&#39;
    # and so this is not a suitable function for use during advection
    #
    # def _return_coords_to_bounds(self, coords, meshVar=None):
    #     &#34;&#34;&#34;
    #     Restore the provided coordinates to the interior of the domain.
    #     The default behaviour is to find the nearest node in the kdtree to each
    #     coordinate and use that value. If a meshVar is provided, we can use the nearest node
    #     for that discretisation instead.

    #     This can be over-ridden for specific meshes
    #     (e.g. periodic) where a more appropriate choice is available.
    #     &#34;&#34;&#34;

    #     import numpy as np

    #     if meshVar is None:
    #         target_coords = self.data
    #     else:
    #         target_coords = meshVar.coords

    #     ## Find which coords are invalid

    #     invalid = self.get_closest_local_cells(coords) == -1

    #     if np.count_nonzero(invalid) == 0:
    #         return coords

    #     print(f&#34;{uw.mpi.rank}: Number of invalid coords {np.count_nonzero(invalid)}&#34;)

    #     kdt = uw.kdtree.KDTree(target_coords)
    #     idx , _ , _ = kdt.find_closest_point(coords[invalid])

    #     valid_coords = coords.copy()
    #     valid_coords[invalid] = target_coords[idx]

    #     return valid_coords

    def clone_dm_hierarchy(self):
        &#34;&#34;&#34;
        Clone the dm hierarchy on the mesh
        &#34;&#34;&#34;

        dm_hierarchy = self.dm_hierarchy

        new_dm_hierarchy = []
        for dm in dm_hierarchy:
            new_dm_hierarchy.append(dm.clone())

        for i, dm in enumerate(new_dm_hierarchy[:-1]):
            new_dm_hierarchy[i + 1].setCoarseDM(new_dm_hierarchy[i])

        return new_dm_hierarchy

    def nuke_coords_and_rebuild(self):
        # This is a reversion to the old version (3.15 compatible which seems to work in 3.16 too)
        #
        #

        self.dm.clearDS()
        self.dm.createDS()

        self._coord_array = {}

        # let&#39;s go ahead and do an initial projection from linear (the default)
        # to linear. this really is a nothing operation, but a
        # side effect of this operation is that coordinate DM DMField is
        # converted to the required `PetscFE` type. this may become necessary
        # later where we call the interpolation routines to project from the linear
        # mesh coordinates to other mesh coordinates.

        options = PETSc.Options()
        options.setValue(
            &#34;meshproj_{}_petscspace_degree&#34;.format(self.mesh_instances), self.degree
        )

        self.petsc_fe = PETSc.FE().createDefault(
            self.dim,
            self.cdim,
            self.isSimplex,
            self.qdegree,
            &#34;meshproj_{}_&#34;.format(self.mesh_instances),
        )

        if (
            PETSc.Sys.getVersion() &lt;= (3, 20, 5)
            and PETSc.Sys.getVersionInfo()[&#34;release&#34;] == True
        ):
            self.dm.projectCoordinates(self.petsc_fe)
        else:
            self.dm.setCoordinateDisc(disc=self.petsc_fe, project=False)

        # now set copy of this array into dictionary

        arr = self.dm.getCoordinatesLocal().array

        key = (
            self.isSimplex,
            self.degree,
            True,
        )  # True here assumes continuous basis for coordinates ...

        self._coord_array[key] = arr.reshape(-1, self.cdim).copy()

        # invalidate the cell-search k-d tree and the mesh centroid data / rebuild
        self._index = None
        self._build_kd_tree_index()

        (
            self._min_size,
            self._radii,
            self._centroids,
            self._search_lengths,
        ) = self._get_mesh_sizes()

        self.dm.copyDS(self.dm_hierarchy[-1])

        return

    @timing.routine_timer_decorator
    def update_lvec(self):
        &#34;&#34;&#34;
        This method creates and/or updates the mesh variable local vector.
        If the local vector is already up to date, this method will do nothing.
        &#34;&#34;&#34;

        if self._stale_lvec:
            if not self._lvec:
                self.dm.clearDS()
                self.dm.createDS()
                # create the local vector (memory chunk) and attach to original dm
                self._lvec = self.dm.createLocalVec()

            # push avar arrays into the parent dm array
            a_global = self.dm.getGlobalVec()

            # The field decomposition seems to fail if coarse DMs are present
            names, isets, dms = self.dm.createFieldDecomposition()

            with self.access():
                # traverse subdms, taking user generated data in the subdm
                # local vec, pushing it into a global sub vec
                for var, subiset, subdm in zip(self.vars.values(), isets, dms):
                    lvec = var.vec
                    subvec = a_global.getSubVector(subiset)
                    subdm.localToGlobal(lvec, subvec, addv=False)
                    a_global.restoreSubVector(subiset, subvec)

            self.dm.globalToLocal(a_global, self._lvec)
            self.dm.restoreGlobalVec(a_global)
            self._stale_lvec = False

    @property
    def lvec(self) -&gt; PETSc.Vec:
        &#34;&#34;&#34;
        Returns a local Petsc vector containing the flattened array
        of all the mesh variables.
        &#34;&#34;&#34;
        if self._stale_lvec:
            raise RuntimeError(
                &#34;Mesh `lvec` needs to be updated using the update_lvec()` method.&#34;
            )
        return self._lvec

    def __del__(self):
        if hasattr(self, &#34;_lvec&#34;) and self._lvec:
            self._lvec.destroy()

    def deform_mesh(self, new_coords: numpy.ndarray, verbose=False):
        &#34;&#34;&#34;
        This method will update the mesh coordinates and reset any cached coordinates in
        the mesh and in equation systems that are registered on the mesh.

        The coord array that is passed in should match the shape of self.data
        &#34;&#34;&#34;

        coord_vec = self.dm.getCoordinatesLocal()
        coords = coord_vec.array.reshape(-1, self.cdim)
        coords[...] = new_coords[...]

        self.dm.setCoordinatesLocal(coord_vec)
        self.nuke_coords_and_rebuild()

        # This should not be necessary any more as we now check the
        # coordinates on the DM to see if they have changed (and we rebuild the
        # discretisation as needed)
        #
        # for eq_system in self._equation_systems_register:
        #     eq_system._rebuild_after_mesh_update(verbose)

        return

    def access(self, *writeable_vars: &#34;MeshVariable&#34;):
        &#34;&#34;&#34;
        This context manager makes the underlying mesh variables data available to
        the user. The data should be accessed via the variables `data` handle.

        As default, all data is read-only. To enable writeable data, the user should
        specify which variable they wish to modify.

        Parameters
        ----------
        writeable_vars
            The variables for which data write access is required.

        Example
        -------
        &gt;&gt;&gt; import underworld3 as uw
        &gt;&gt;&gt; someMesh = uw.discretisation.FeMesh_Cartesian()
        &gt;&gt;&gt; with someMesh.deform_mesh():
        ...     someMesh.data[0] = [0.1,0.1]
        &gt;&gt;&gt; someMesh.data[0]
        array([ 0.1,  0.1])
        &#34;&#34;&#34;

        import time

        timing._incrementDepth()
        stime = time.time()

        if writeable_vars is not None:
            self._evaluation_hash = None
            self._evaluation_interpolated_results = None

        self._accessed = True
        deaccess_list = []
        for var in self.vars.values():
            # if already accessed within higher level context manager, continue.
            if var._is_accessed == True:
                continue

            # set flag so variable status can be known elsewhere
            var._is_accessed = True
            # add to de-access list to rewind this later
            deaccess_list.append(var)

            # create &amp; set vec
            var._set_vec(available=True)

            # grab numpy object, setting read only if necessary
            var._data = var.vec.array.reshape(-1, var.num_components)

            if var not in writeable_vars:
                var._old_data_flag = var._data.flags.writeable
                var._data.flags.writeable = False
            else:
                # increment variable state
                var._increment()

            # make view for each var component

            for i in range(0, var.shape[0]):
                for j in range(0, var.shape[1]):
                    # var._data_ij[i, j] = var.data[:, var._data_layout(i, j)]
                    var._data_container[i, j] = var._data_container[i, j]._replace(
                        data=var.data[:, var._data_layout(i, j)],
                    )

        class exit_manager:
            def __init__(self, mesh):
                self.mesh = mesh

            def __enter__(self):
                pass

            def __exit__(self, *args):
                for var in self.mesh.vars.values():
                    # only de-access variables we have set access for.
                    if var not in deaccess_list:
                        continue
                    # set this back, although possibly not required.
                    if var not in writeable_vars:
                        var._data.flags.writeable = var._old_data_flag
                    # perform sync for any modified vars.

                    if var in writeable_vars:
                        indexset, subdm = self.mesh.dm.createSubDM(var.field_id)

                        # sync ghost values
                        subdm.localToGlobal(var.vec, var._gvec, addv=False)
                        subdm.globalToLocal(var._gvec, var.vec, addv=False)

                        # subdm.destroy()
                        self.mesh._stale_lvec = True

                    var._data = None
                    var._set_vec(available=False)
                    var._is_accessed = False

                    for i in range(0, var.shape[0]):
                        for j in range(0, var.shape[1]):
                            var._data_container[i, j] = var._data_container[
                                i, j
                            ]._replace(
                                data=f&#34;MeshVariable[...].data is only available within mesh.access() context&#34;,
                            )

                timing._decrementDepth()
                timing.log_result(time.time() - stime, &#34;Mesh.access&#34;, 1)

        return exit_manager(self)

    @property
    def N(self) -&gt; sympy.vector.CoordSys3D:
        &#34;&#34;&#34;
        The mesh coordinate system.
        &#34;&#34;&#34;
        return self._N

    @property
    def Gamma_N(self) -&gt; sympy.vector.CoordSys3D:
        &#34;&#34;&#34;
        The mesh coordinate system.
        &#34;&#34;&#34;
        return self._Gamma

    @property
    def Gamma(self) -&gt; sympy.vector.CoordSys3D:
        &#34;&#34;&#34;
        The mesh coordinate system.
        &#34;&#34;&#34;
        return sympy.Matrix(self._Gamma.base_scalars()[0 : self.cdim]).T

    @property
    def X(self) -&gt; sympy.Matrix:
        return self._CoordinateSystem.X

    @property
    def CoordinateSystem(self) -&gt; CoordinateSystem:
        return self._CoordinateSystem

    @property
    def r(self) -&gt; Tuple[sympy.vector.BaseScalar]:
        &#34;&#34;&#34;
        The tuple of base scalar objects (N.x,N.y,N.z) for the mesh.
        &#34;&#34;&#34;
        return self._N.base_scalars()[0 : self.cdim]

    @property
    def rvec(self) -&gt; sympy.vector.Vector:
        &#34;&#34;&#34;
        The r vector, `r = N.x*N.i + N.y*N.j [+ N.z*N.k]`.
        &#34;&#34;&#34;
        N = self.N

        r_vec = sympy.vector.Vector.zero

        N_s = N.base_scalars()
        N_v = N.base_vectors()
        for i in range(self.cdim):
            r_vec += N_s[i] * N_v[i]

        return r_vec

    @property
    def data(self) -&gt; numpy.ndarray:
        &#34;&#34;&#34;
        The array of mesh element vertex coordinates.
        &#34;&#34;&#34;
        # get flat array
        arr = self.dm.getCoordinatesLocal().array
        return arr.reshape(-1, self.cdim)

    @timing.routine_timer_decorator
    def write_timestep(
        self,
        filename: str,
        index: int,
        outputPath: Optional[str] = &#34;&#34;,
        meshVars: Optional[list] = [],
        swarmVars: Optional[list] = [],
        meshUpdates: bool = False,
    ):
        &#34;&#34;&#34;
        Write the selected mesh, variables and swarm variables (as proxies) for later visualisation.
        An xdmf file is generated and the overall package can then be read by paraview or pyvista.
        Vertex values (on the mesh points) are stored for all variables regardless of their interpolation order
        &#34;&#34;&#34;

        options = PETSc.Options()
        options.setValue(&#34;viewer_hdf5_sp_output&#34;, True)
        options.setValue(&#34;viewer_hdf5_collective&#34;, False)

        output_base_name = os.path.join(outputPath, filename)

        # check the directory where we will write checkpoint
        dir_path = os.path.dirname(output_base_name)  # get directory

        # check if path exists
        if os.path.exists(os.path.abspath(dir_path)):  # easier to debug abs
            pass
        else:
            raise RuntimeError(f&#34;{os.path.abspath(dir_path)} does not exist&#34;)

        # check if we have write access
        if os.access(os.path.abspath(dir_path), os.W_OK):
            pass
        else:
            raise RuntimeError(f&#34;No write access to {os.path.abspath(dir_path)}&#34;)

        # Checkpoint the mesh file itself if required

        if not meshUpdates:
            from pathlib import Path

            mesh_file = output_base_name + &#34;.mesh.00000.h5&#34;
            path = Path(mesh_file)
            if not path.is_file():
                self.write(mesh_file)

        else:
            self.write(output_base_name + f&#34;.mesh.{index:05}.h5&#34;)

        if meshVars is not None:
            for var in meshVars:
                save_location = (
                    output_base_name + f&#34;.mesh.{var.clean_name}.{index:05}.h5&#34;
                )
                var.write(save_location)

        if swarmVars is not None:
            for svar in swarmVars:
                save_location = (
                    output_base_name + f&#34;.proxy.{svar.clean_name}.{index:05}.h5&#34;
                )
                svar.write(save_location)

        if uw.mpi.rank == 0:
            checkpoint_xdmf(
                output_base_name,
                meshUpdates,
                meshVars,
                swarmVars,
                index,
            )

        return

    @timing.routine_timer_decorator
    def petsc_save_checkpoint(
        self,
        index: int,
        meshVars: Optional[list] = [],
        outputPath: Optional[str] = &#34;&#34;,
    ):
        &#34;&#34;&#34;

        Use PETSc to save the mesh and mesh vars in a h5 and xdmf file.

        Parameters
        ----------
        meshVars:
            List of UW mesh variables to save. If left empty then just the mesh is saved.
        index :
            An index which might correspond to the timestep or output number (for example).
        outputPath :
            Path to save the data. If left empty it will save the data in the current working directory.
        &#34;&#34;&#34;

        if meshVars != None and not isinstance(meshVars, list):
            raise RuntimeError(&#34;`meshVars` does not appear to be a list.&#34;)

        from underworld3.utilities import generateXdmf

        ### save mesh vars
        fname = f&#34;./{outputPath}{&#39;_step_&#39;}{index:05d}.h5&#34;
        xfname = f&#34;./{outputPath}{&#39;_step_&#39;}{index:05d}.xdmf&#34;
        #### create petsc viewer
        viewer = PETSc.ViewerHDF5().createHDF5(
            fname, mode=PETSc.Viewer.Mode.WRITE, comm=PETSc.COMM_WORLD
        )

        viewer(self.dm)

        ### Empty meshVars will save just the mesh
        if meshVars != None:
            for var in meshVars:
                viewer(var._gvec)

        viewer.destroy()

        if uw.mpi.rank == 0:
            generateXdmf(fname, xfname)

    @timing.routine_timer_decorator
    def write_checkpoint(
        self,
        filename: str,
        meshUpdates: bool = True,
        meshVars: Optional[list] = [],
        swarmVars: Optional[list] = [],
        index: Optional[int] = 0,
        unique_id: Optional[bool] = False,
    ):
        &#34;&#34;&#34;Write data in a format that can be restored for restarting the simulation
        The difference between this and the visualisation is 1) the parallel section needs
        to be stored to reload the data correctly, and 2) the visualisation information (vertex form of fields)
        is not stored. This routines uses dmplex *VectorView and *VectorLoad functionality

        &#34;&#34;&#34;

        # The mesh checkpoint is the same as the one required for visualisation

        if not meshUpdates:
            from pathlib import Path

            mesh_file = filename + &#34;.mesh.0.h5&#34;
            path = Path(mesh_file)
            if not path.is_file():
                self.save(mesh_file)

        else:
            self.save(filename + f&#34;.mesh.{index:05}.h5&#34;)

        # Checkpoint file

        if unique_id:
            checkpoint_file = filename + f&#34;{uw.mpi.unique}.checkpoint.{index:05}.h5&#34;
        else:
            checkpoint_file = filename + f&#34;.checkpoint.{index:05}.h5&#34;

        self.dm.setName(&#34;uw_mesh&#34;)
        viewer = PETSc.ViewerHDF5().create(checkpoint_file, &#34;w&#34;, comm=PETSc.COMM_WORLD)

        # Store the parallel-mesh section information for restoring the checkpoint.
        self.dm.sectionView(viewer, self.dm)

        if meshVars is not None:
            for var in meshVars:
                iset, subdm = self.dm.createSubDM(var.field_id)
                subdm.setName(var.clean_name)
                self.dm.globalVectorView(viewer, subdm, var._gvec)
                self.dm.sectionView(viewer, subdm)
                # v._gvec.view(viewer) # would add viz information plus a duplicate of the data

        if swarmVars is not None:
            for svar in swarmVars:
                var = svar._meshVar
                iset, subdm = self.dm.createSubDM(var.field_id)
                subdm.setName(var.clean_name)
                self.dm.globalVectorView(viewer, subdm, var._gvec)
                self.dm.sectionView(viewer, subdm)

        uw.mpi.barrier()  # should not be required
        viewer.destroy()

    @timing.routine_timer_decorator
    def write(self, filename: str, index: Optional[int] = None):
        &#34;&#34;&#34;
        Save mesh data to the specified hdf5 file.


        Parameters
        ----------
        filename :
            The filename for the mesh checkpoint file.
        index :
            Not yet implemented. An optional index which might
            correspond to the timestep (for example).

        &#34;&#34;&#34;

        viewer = PETSc.ViewerHDF5().create(filename, &#34;w&#34;, comm=PETSc.COMM_WORLD)
        if index:
            raise RuntimeError(&#34;Recording `index` not currently supported&#34;)
            ## JM:To enable timestep recording, the following needs to be called.
            ## I&#39;m unsure if the corresponding xdmf functionality is enabled via
            ## the PETSc xdmf script.
            # viewer.pushTimestepping(viewer)
            # viewer.setTimestep(index)

        viewer(self.dm)

        # Not sure if the files are correctly written if we do not explicitly destroy the viewer
        viewer.destroy()

    def vtk(self, filename: str):
        &#34;&#34;&#34;
        Save mesh to the specified file
        &#34;&#34;&#34;

        viewer = PETSc.Viewer().createVTK(filename, &#34;w&#34;, comm=PETSc.COMM_WORLD)
        viewer(self.dm)
        viewer.destroy()

    def generate_xdmf(self, filename: str):
        &#34;&#34;&#34;
        This method generates an xdmf schema for the specified file.

        The filename of the generated file will be the same as the hdf5 file
        but with the `xmf` extension.

        Parameters
        ----------
        filename :
            File name of the checkpointed hdf5 file for which the
            xdmf schema will be written.
        &#34;&#34;&#34;
        from underworld3.utilities import generateXdmf

        if uw.mpi.rank == 0:
            generateXdmf(filename)

        return

    # ToDo: rename this so it does not clash with the vars built in
    @property
    def vars(self):
        &#34;&#34;&#34;
        A list of variables recorded on the mesh.
        &#34;&#34;&#34;
        return self._vars

        # ToDo: rename this so it does not clash with the vars built in

    @property
    def block_vars(self):
        &#34;&#34;&#34;
        A list of variables recorded on the mesh.
        &#34;&#34;&#34;
        return self._block_vars

    def _get_coords_for_var(self, var):
        &#34;&#34;&#34;
        This function returns the vertex array for the
        provided variable. If the array does not already exist,
        it is first created and then returned.
        &#34;&#34;&#34;
        key = (self.isSimplex, var.degree, var.continuous)

        # if array already created, return.
        if key in self._coord_array:
            return self._coord_array[key]
        else:
            self._coord_array[key] = self._get_coords_for_basis(
                var.degree, var.continuous
            )
            return self._coord_array[key]

    def _get_coords_for_basis(self, degree, continuous):
        &#34;&#34;&#34;
        This function returns the vertex array for the
        provided variable. If the array does not already exist,
        it is first created and then returned.
        &#34;&#34;&#34;

        dmold = self.dm.getCoordinateDM()
        dmold.createDS()
        dmnew = dmold.clone()

        options = PETSc.Options()
        options[&#34;coordinterp_petscspace_degree&#34;] = degree
        options[&#34;coordinterp_petscdualspace_lagrange_continuity&#34;] = continuous
        options[&#34;coordinterp_petscdualspace_lagrange_node_endpoints&#34;] = False

        dmfe = PETSc.FE().createDefault(
            self.dim,
            self.cdim,
            self.isSimplex,
            self.qdegree,
            &#34;coordinterp_&#34;,
            PETSc.COMM_SELF,
        )

        dmnew.setField(0, dmfe)
        dmnew.createDS()

        matInterp, vecScale = dmold.createInterpolation(dmnew)
        coordsOld = self.dm.getCoordinates()
        coordsNewL = dmnew.getLocalVec()
        coordsNewG = dmnew.getGlobalVec()
        matInterp.mult(coordsOld, coordsNewG)
        dmnew.globalToLocal(coordsNewG, coordsNewL)

        arr = coordsNewL.array
        arrcopy = arr.reshape(-1, self.cdim).copy()

        dmnew.restoreGlobalVec(coordsNewG)
        dmnew.restoreLocalVec(coordsNewL)
        dmnew.destroy()
        dmfe.destroy()

        return arrcopy

    def _build_kd_tree_index(self):

        if hasattr(self, &#34;_index&#34;) and self._index is not None:
            return

        ## Bootstrapping - the kd-tree is needed to build the index but
        ## the index is also used in the kd-tree.

        from underworld3.swarm import Swarm, SwarmPICLayout

        # Create a temp swarm which we&#39;ll use to populate particles
        # at gauss points. These will then be used as basis for
        # kd-tree indexing back to owning cells.

        from petsc4py import PETSc

        tempSwarm = PETSc.DMSwarm().create()
        tempSwarm.setDimension(self.dim)
        tempSwarm.setCellDM(self.dm)
        tempSwarm.setType(PETSc.DMSwarm.Type.PIC)
        tempSwarm.finalizeFieldRegister()

        # 3^dim or 4^dim pop is used. This number may need to be considered
        # more carefully, or possibly should be coded to be set dynamically.

        tempSwarm.insertPointUsingCellDM(PETSc.DMSwarm.PICLayoutType.LAYOUT_GAUSS, 4)

        # We can&#39;t use our own populate function since this needs THIS kd_tree to exist
        # We will need to use a standard layout instead

        ## ?? is this required given no migration ??
        # tempSwarm.migrate(remove_sent_points=True)

        PIC_coords = tempSwarm.getField(&#34;DMSwarmPIC_coor&#34;).reshape(-1, self.dim)
        PIC_cellid = tempSwarm.getField(&#34;DMSwarm_cellid&#34;)

        self._indexCoords = PIC_coords.copy()
        self._index = uw.kdtree.KDTree(self._indexCoords)
        self._index.build_index()
        self._indexMap = numpy.array(PIC_cellid, dtype=numpy.int64)

        tempSwarm.restoreField(&#34;DMSwarmPIC_coor&#34;)
        tempSwarm.restoreField(&#34;DMSwarm_cellid&#34;)

        tempSwarm.destroy()

        return

    @timing.routine_timer_decorator
    def get_closest_cells(self, coords: numpy.ndarray) -&gt; numpy.ndarray:
        &#34;&#34;&#34;
        This method uses a kd-tree algorithm to find the closest
        cells to the provided coords. For a regular mesh, this should
        be exactly the owning cell, but if the mesh is deformed, this
        is not guaranteed. Note, the nearest point does may not be all
        that close by - use get_closest_local_cells to filter out points
        that are (probably) not within any local cell.

        Parameters:
        -----------
        coords:
            An array of the coordinates for which we wish to determine the
            closest cells. This should be a 2-dimensional array of
            shape (n_coords,dim).

        Returns:
        --------
        closest_cells:
            An array of indices representing the cells closest to the provided
            coordinates. This will be a 1-dimensional array of
            shape (n_coords).
        &#34;&#34;&#34;

        self._build_kd_tree_index()

        if len(coords) &gt; 0:
            closest_points, dist, found = self._index.find_closest_point(coords)
        else:
            ### returns an empty array if no coords are on a proc
            closest_points, dist, found = False, False, numpy.array([None])

        if found.any() != None:
            if not numpy.allclose(found, True):
                raise RuntimeError(
                    &#34;An error was encountered attempting to find the closest cells to the provided coordinates.&#34;
                )

        return self._indexMap[closest_points]

    def get_closest_local_cells(self, coords: numpy.ndarray) -&gt; numpy.ndarray:
        &#34;&#34;&#34;
        This method uses a kd-tree algorithm to find the closest
        cells to the provided coords. For a regular mesh, this should
        be exactly the owning cell, but if the mesh is deformed, this
        is not guaranteed. Also compares the distance from the cell to the
        point - if this is larger than the &#34;cell size&#34; then returns -1

        Parameters:
        -----------
        coords:
            An array of the coordinates for which we wish to determine the
            closest cells. This should be a 2-dimensional array of
            shape (n_coords,dim).

        Returns:
        --------
        closest_cells:
            An array of indices representing the cells closest to the provided
            coordinates. This will be a 1-dimensional array of
            shape (n_coords).


        &#34;&#34;&#34;

        # Create index if required
        self._build_kd_tree_index()

        if len(coords) &gt; 0:
            closest_points, dist, found = self._index.find_closest_point(coords)
        else:
            return -1

        # This is tuned a little bit so that points on a single CPU are never lost

        cells = self._indexMap[closest_points]
        invalid = (
            dist &gt; 0.1 * self._radii[cells] ** 2  # 2.5 * self._search_lengths[cells]
        )  # 0.25 * self._radii[cells] ** 2
        cells[invalid] = -1

        return cells

    def _get_mesh_sizes(self, verbose=False):
        &#34;&#34;&#34;
        Obtain the (local) mesh radii and centroids using
        This routine is called when the mesh is built / rebuilt

        &#34;&#34;&#34;

        centroids = self._get_coords_for_basis(0, False)
        centroids_kd_tree = uw.kdtree.KDTree(centroids)

        import numpy as np

        cStart, cEnd = self.dm.getHeightStratum(0)
        pStart, pEnd = self.dm.getDepthStratum(0)
        cell_length = np.empty(centroids.shape[0])
        cell_min_r = np.empty(centroids.shape[0])
        cell_r = np.empty(centroids.shape[0])

        for cell in range(cEnd - cStart):
            cell_num_points = self.dm.getConeSize(cell)
            cell_points = self.dm.getTransitiveClosure(cell)[0][-cell_num_points:]
            cell_coords = self.data[cell_points - pStart]

            _, distsq, _ = centroids_kd_tree.find_closest_point(cell_coords)

            cell_length[cell] = np.sqrt(distsq.max())
            cell_r[cell] = np.sqrt(distsq.mean())
            cell_min_r[cell] = np.sqrt(distsq.min())

        return cell_min_r, cell_r, centroids, cell_length

    # ==========

    # Deprecated in favour of _get_mesh_sizes (above)
    def _get_mesh_centroids(self):
        &#34;&#34;&#34;
        Obtain and cache the (local) mesh centroids using underworld swarm technology.
        This routine is called when the mesh is built / rebuilt

        The global cell number corresponding to a centroid is (supposed to be)
        self.dm.getCellNumbering().array.min() + index

        &#34;&#34;&#34;

        # (
        #     sizes,
        #     centroids,
        # ) = petsc_discretisation.petsc_fvm_get_local_cell_sizes(self)

        centroids = self._get_coords_for_basis(0, False)

        return centroids

    def get_min_radius_old(self) -&gt; float:
        &#34;&#34;&#34;
        This method returns the global minimum distance from any cell centroid to a face.
        It wraps to the PETSc `DMPlexGetMinRadius` routine. The petsc4py equivalent always
        returns zero.
        &#34;&#34;&#34;

        ## Note: The petsc4py version of DMPlexComputeGeometryFVM does not compute all cells and
        ## does not obtain the minimum radius for the mesh.

        from underworld3.cython.petsc_discretisation import petsc_fvm_get_min_radius

        if (not hasattr(self, &#34;_min_radius&#34;)) or (self._min_radius == None):
            self._min_radius = petsc_fvm_get_min_radius(self)

        return self._min_radius

    def get_min_radius(self) -&gt; float:
        &#34;&#34;&#34;
        This method returns the global minimum distance from any cell centroid to a face.
        It wraps to the PETSc `DMPlexGetMinRadius` routine. The petsc4py equivalent always
        returns zero.
        &#34;&#34;&#34;

        ## Note: The petsc4py version of DMPlexComputeGeometryFVM does not compute all cells and
        ## does not obtain the minimum radius for the mesh.

        import numpy as np

        all_min_radii = uw.utilities.gather_data(
            np.array((self._radii.min(),)), bcast=True
        )

        return all_min_radii.min()

    def get_max_radius(self) -&gt; float:
        &#34;&#34;&#34;
        This method returns the global maximum distance from any cell centroid to a face.
        &#34;&#34;&#34;

        ## Note: The petsc4py version of DMPlexComputeGeometryFVM does not compute all cells and
        ## does not obtain the minimum radius for the mesh.

        import numpy as np

        all_max_radii = uw.utilities.gather_data(
            np.array((self._radii.max(),)), bcast=True
        )

        return all_max_radii.max()

    # def get_boundary_subdm(self) -&gt; PETSc.DM:
    #     &#34;&#34;&#34;
    #     This method returns the boundary subdm that wraps DMPlexCreateSubmesh
    #     &#34;&#34;&#34;
    #     from underworld3.petsc_discretisation import petsc_create_surface_submesh
    #     return petsc_create_surface_submesh(self, &#34;Boundary&#34;, 666, )

    # This should be deprecated in favour of using integrals
    def stats(self, uw_function, uw_meshVariable, basis=None):
        &#34;&#34;&#34;
        Returns various norms on the mesh for the provided function.
          - size
          - mean
          - min
          - max
          - sum
          - L2 norm
          - rms

          NOTE: this currently assumes scalar variables !
        &#34;&#34;&#34;

        #       This uses a private work MeshVariable and the various norms defined there but
        #       could either be simplified to just use petsc vectors, or extended to
        #       compute integrals over the elements which is in line with uw1 and uw2

        if basis is None:
            basis = self.N

        from petsc4py.PETSc import NormType

        tmp = uw_meshVariable

        with self.access(tmp):
            tmp.data[...] = uw.function.evaluate(
                uw_function, tmp.coords, basis
            ).reshape(-1, 1)

        vsize = tmp._gvec.getSize()
        vmean = tmp.mean()
        vmax = tmp.max()[1]
        vmin = tmp.min()[1]
        vsum = tmp.sum()
        vnorm2 = tmp.norm(NormType.NORM_2)
        vrms = vnorm2 / numpy.sqrt(vsize)

        return vsize, vmean, vmin, vmax, vsum, vnorm2, vrms

    def meshVariable_mask_from_label(self, label_name, label_value):
        &#34;&#34;&#34;Extract single label value and make a point mask - note: this produces a mask on the mesh points and
        assumes a 1st order mesh. Cell labels are not respected in this function.&#34;&#34;&#34;

        meshVar = MeshVariable(
            f&#34;Mask_{label_name}_{label_value}&#34;,
            self,
            vtype=uw.VarType.SCALAR,
            degree=1,
            continuous=True,
            varsymbol=rf&#34;\cal{{M}}^{{[{label_name:.4}]}}&#34;,
        )

        point_indices = petsc_dm_find_labeled_points_local(
            self.dm,
            label_name,
            label_value,
            sectionIndex=False,
        )

        with self.access(meshVar):
            meshVar.data[...] = 0.0
            if point_indices is not None:
                meshVar.data[point_indices] = 1.0

        return meshVar</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>underworld3.utilities._api_tools.Stateful</li>
<li>underworld3.utilities._api_tools.uw_object</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="underworld3.discretisation.Mesh.mesh_instances"><code class="name">var <span class="ident">mesh_instances</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="underworld3.discretisation.Mesh.CoordinateSystem"><code class="name">prop <span class="ident">CoordinateSystem</span> : <a title="underworld3.coordinates.CoordinateSystem" href="coordinates.html#underworld3.coordinates.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def CoordinateSystem(self) -&gt; CoordinateSystem:
    return self._CoordinateSystem</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.Gamma"><code class="name">prop <span class="ident">Gamma</span> : sympy.vector.coordsysrect.CoordSys3D</code></dt>
<dd>
<div class="desc"><p>The mesh coordinate system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Gamma(self) -&gt; sympy.vector.CoordSys3D:
    &#34;&#34;&#34;
    The mesh coordinate system.
    &#34;&#34;&#34;
    return sympy.Matrix(self._Gamma.base_scalars()[0 : self.cdim]).T</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.Gamma_N"><code class="name">prop <span class="ident">Gamma_N</span> : sympy.vector.coordsysrect.CoordSys3D</code></dt>
<dd>
<div class="desc"><p>The mesh coordinate system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Gamma_N(self) -&gt; sympy.vector.CoordSys3D:
    &#34;&#34;&#34;
    The mesh coordinate system.
    &#34;&#34;&#34;
    return self._Gamma</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.N"><code class="name">prop <span class="ident">N</span> : sympy.vector.coordsysrect.CoordSys3D</code></dt>
<dd>
<div class="desc"><p>The mesh coordinate system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def N(self) -&gt; sympy.vector.CoordSys3D:
    &#34;&#34;&#34;
    The mesh coordinate system.
    &#34;&#34;&#34;
    return self._N</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.X"><code class="name">prop <span class="ident">X</span> : sympy.matrices.dense.MutableDenseMatrix</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def X(self) -&gt; sympy.Matrix:
    return self._CoordinateSystem.X</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.block_vars"><code class="name">prop <span class="ident">block_vars</span></code></dt>
<dd>
<div class="desc"><p>A list of variables recorded on the mesh.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def block_vars(self):
    &#34;&#34;&#34;
    A list of variables recorded on the mesh.
    &#34;&#34;&#34;
    return self._block_vars</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.cdim"><code class="name">prop <span class="ident">cdim</span> : int</code></dt>
<dd>
<div class="desc"><p>The mesh dimensionality.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cdim(self) -&gt; int:
    &#34;&#34;&#34;
    The mesh dimensionality.
    &#34;&#34;&#34;
    return self.dm.getCoordinateDim()</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.data"><code class="name">prop <span class="ident">data</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The array of mesh element vertex coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self) -&gt; numpy.ndarray:
    &#34;&#34;&#34;
    The array of mesh element vertex coordinates.
    &#34;&#34;&#34;
    # get flat array
    arr = self.dm.getCoordinatesLocal().array
    return arr.reshape(-1, self.cdim)</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.dim"><code class="name">prop <span class="ident">dim</span> : int</code></dt>
<dd>
<div class="desc"><p>The mesh dimensionality.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dim(self) -&gt; int:
    &#34;&#34;&#34;
    The mesh dimensionality.
    &#34;&#34;&#34;
    return self.dm.getDimension()</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.lvec"><code class="name">prop <span class="ident">lvec</span> : petsc4py.PETSc.Vec</code></dt>
<dd>
<div class="desc"><p>Returns a local Petsc vector containing the flattened array
of all the mesh variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lvec(self) -&gt; PETSc.Vec:
    &#34;&#34;&#34;
    Returns a local Petsc vector containing the flattened array
    of all the mesh variables.
    &#34;&#34;&#34;
    if self._stale_lvec:
        raise RuntimeError(
            &#34;Mesh `lvec` needs to be updated using the update_lvec()` method.&#34;
        )
    return self._lvec</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.r"><code class="name">prop <span class="ident">r</span> : Tuple[sympy.vector.scalar.BaseScalar]</code></dt>
<dd>
<div class="desc"><p>The tuple of base scalar objects (N.x,N.y,N.z) for the mesh.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def r(self) -&gt; Tuple[sympy.vector.BaseScalar]:
    &#34;&#34;&#34;
    The tuple of base scalar objects (N.x,N.y,N.z) for the mesh.
    &#34;&#34;&#34;
    return self._N.base_scalars()[0 : self.cdim]</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.rvec"><code class="name">prop <span class="ident">rvec</span> : sympy.vector.vector.Vector</code></dt>
<dd>
<div class="desc"><p>The r vector, <code>r = N.x*N.i + N.y*N.j [+ N.z*N.k]</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rvec(self) -&gt; sympy.vector.Vector:
    &#34;&#34;&#34;
    The r vector, `r = N.x*N.i + N.y*N.j [+ N.z*N.k]`.
    &#34;&#34;&#34;
    N = self.N

    r_vec = sympy.vector.Vector.zero

    N_s = N.base_scalars()
    N_v = N.base_vectors()
    for i in range(self.cdim):
        r_vec += N_s[i] * N_v[i]

    return r_vec</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.vars"><code class="name">prop <span class="ident">vars</span></code></dt>
<dd>
<div class="desc"><p>A list of variables recorded on the mesh.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def vars(self):
    &#34;&#34;&#34;
    A list of variables recorded on the mesh.
    &#34;&#34;&#34;
    return self._vars

    # ToDo: rename this so it does not clash with the vars built in</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="underworld3.discretisation.Mesh.access"><code class="name flex">
<span>def <span class="ident">access</span></span>(<span>self, *writeable_vars: <a title="underworld3.discretisation.MeshVariable" href="#underworld3.discretisation.MeshVariable">MeshVariable()</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This context manager makes the underlying mesh variables data available to
the user. The data should be accessed via the variables <code>data</code> handle.</p>
<p>As default, all data is read-only. To enable writeable data, the user should
specify which variable they wish to modify.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>writeable_vars</code></strong></dt>
<dd>The variables for which data write access is required.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import underworld3 as uw
&gt;&gt;&gt; someMesh = uw.discretisation.FeMesh_Cartesian()
&gt;&gt;&gt; with someMesh.deform_mesh():
...     someMesh.data[0] = [0.1,0.1]
&gt;&gt;&gt; someMesh.data[0]
array([ 0.1,  0.1])
</code></pre></div>
</dd>
<dt id="underworld3.discretisation.Mesh.clone_dm_hierarchy"><code class="name flex">
<span>def <span class="ident">clone_dm_hierarchy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clone the dm hierarchy on the mesh</p></div>
</dd>
<dt id="underworld3.discretisation.Mesh.deform_mesh"><code class="name flex">
<span>def <span class="ident">deform_mesh</span></span>(<span>self, new_coords: numpy.ndarray, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This method will update the mesh coordinates and reset any cached coordinates in
the mesh and in equation systems that are registered on the mesh.</p>
<p>The coord array that is passed in should match the shape of self.data</p></div>
</dd>
<dt id="underworld3.discretisation.Mesh.generate_xdmf"><code class="name flex">
<span>def <span class="ident">generate_xdmf</span></span>(<span>self, filename: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This method generates an xdmf schema for the specified file.</p>
<p>The filename of the generated file will be the same as the hdf5 file
but with the <code>xmf</code> extension.</p>
<h2 id="parameters">Parameters</h2>
<p>filename :
File name of the checkpointed hdf5 file for which the
xdmf schema will be written.</p></div>
</dd>
<dt id="underworld3.discretisation.Mesh.get_closest_cells"><code class="name flex">
<span>def <span class="ident">get_closest_cells</span></span>(<span>self, coords: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>This method uses a kd-tree algorithm to find the closest
cells to the provided coords. For a regular mesh, this should
be exactly the owning cell, but if the mesh is deformed, this
is not guaranteed. Note, the nearest point does may not be all
that close by - use get_closest_local_cells to filter out points
that are (probably) not within any local cell.</p>
<h2 id="parameters">Parameters:</h2>
<p>coords:
An array of the coordinates for which we wish to determine the
closest cells. This should be a 2-dimensional array of
shape (n_coords,dim).</p>
<h2 id="returns">Returns:</h2>
<p>closest_cells:
An array of indices representing the cells closest to the provided
coordinates. This will be a 1-dimensional array of
shape (n_coords).</p></div>
</dd>
<dt id="underworld3.discretisation.Mesh.get_closest_local_cells"><code class="name flex">
<span>def <span class="ident">get_closest_local_cells</span></span>(<span>self, coords: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>This method uses a kd-tree algorithm to find the closest
cells to the provided coords. For a regular mesh, this should
be exactly the owning cell, but if the mesh is deformed, this
is not guaranteed. Also compares the distance from the cell to the
point - if this is larger than the "cell size" then returns -1</p>
<h2 id="parameters">Parameters:</h2>
<p>coords:
An array of the coordinates for which we wish to determine the
closest cells. This should be a 2-dimensional array of
shape (n_coords,dim).</p>
<h2 id="returns">Returns:</h2>
<p>closest_cells:
An array of indices representing the cells closest to the provided
coordinates. This will be a 1-dimensional array of
shape (n_coords).</p></div>
</dd>
<dt id="underworld3.discretisation.Mesh.get_max_radius"><code class="name flex">
<span>def <span class="ident">get_max_radius</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>This method returns the global maximum distance from any cell centroid to a face.</p></div>
</dd>
<dt id="underworld3.discretisation.Mesh.get_min_radius"><code class="name flex">
<span>def <span class="ident">get_min_radius</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>This method returns the global minimum distance from any cell centroid to a face.
It wraps to the PETSc <code>DMPlexGetMinRadius</code> routine. The petsc4py equivalent always
returns zero.</p></div>
</dd>
<dt id="underworld3.discretisation.Mesh.get_min_radius_old"><code class="name flex">
<span>def <span class="ident">get_min_radius_old</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>This method returns the global minimum distance from any cell centroid to a face.
It wraps to the PETSc <code>DMPlexGetMinRadius</code> routine. The petsc4py equivalent always
returns zero.</p></div>
</dd>
<dt id="underworld3.discretisation.Mesh.meshVariable_mask_from_label"><code class="name flex">
<span>def <span class="ident">meshVariable_mask_from_label</span></span>(<span>self, label_name, label_value)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract single label value and make a point mask - note: this produces a mask on the mesh points and
assumes a 1st order mesh. Cell labels are not respected in this function.</p></div>
</dd>
<dt id="underworld3.discretisation.Mesh.nuke_coords_and_rebuild"><code class="name flex">
<span>def <span class="ident">nuke_coords_and_rebuild</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="underworld3.discretisation.Mesh.petsc_save_checkpoint"><code class="name flex">
<span>def <span class="ident">petsc_save_checkpoint</span></span>(<span>self, index: int, meshVars: Optional[list] = [], outputPath: Optional[str] = '')</span>
</code></dt>
<dd>
<div class="desc"><p>Use PETSc to save the mesh and mesh vars in a h5 and xdmf file.</p>
<h2 id="parameters">Parameters</h2>
<p>meshVars:
List of UW mesh variables to save. If left empty then just the mesh is saved.
index :
An index which might correspond to the timestep or output number (for example).
outputPath :
Path to save the data. If left empty it will save the data in the current working directory.</p></div>
</dd>
<dt id="underworld3.discretisation.Mesh.stats"><code class="name flex">
<span>def <span class="ident">stats</span></span>(<span>self, uw_function, uw_meshVariable, basis=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns various norms on the mesh for the provided function.
- size
- mean
- min
- max
- sum
- L2 norm
- rms</p>
<p>NOTE: this currently assumes scalar variables !</p></div>
</dd>
<dt id="underworld3.discretisation.Mesh.update_lvec"><code class="name flex">
<span>def <span class="ident">update_lvec</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method creates and/or updates the mesh variable local vector.
If the local vector is already up to date, this method will do nothing.</p></div>
</dd>
<dt id="underworld3.discretisation.Mesh.view"><code class="name flex">
<span>def <span class="ident">view</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="underworld3.discretisation.Mesh.view_parallel"><code class="name flex">
<span>def <span class="ident">view_parallel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the break down of boundary labels from each processor</p></div>
</dd>
<dt id="underworld3.discretisation.Mesh.vtk"><code class="name flex">
<span>def <span class="ident">vtk</span></span>(<span>self, filename: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Save mesh to the specified file</p></div>
</dd>
<dt id="underworld3.discretisation.Mesh.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, filename: str, index: Optional[int] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save mesh data to the specified hdf5 file.</p>
<h2 id="parameters">Parameters</h2>
<p>filename :
The filename for the mesh checkpoint file.
index :
Not yet implemented. An optional index which might
correspond to the timestep (for example).</p></div>
</dd>
<dt id="underworld3.discretisation.Mesh.write_checkpoint"><code class="name flex">
<span>def <span class="ident">write_checkpoint</span></span>(<span>self, filename: str, meshUpdates: bool = True, meshVars: Optional[list] = [], swarmVars: Optional[list] = [], index: Optional[int] = 0, unique_id: Optional[bool] = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Write data in a format that can be restored for restarting the simulation
The difference between this and the visualisation is 1) the parallel section needs
to be stored to reload the data correctly, and 2) the visualisation information (vertex form of fields)
is not stored. This routines uses dmplex <em>VectorView and </em>VectorLoad functionality</p></div>
</dd>
<dt id="underworld3.discretisation.Mesh.write_timestep"><code class="name flex">
<span>def <span class="ident">write_timestep</span></span>(<span>self, filename: str, index: int, outputPath: Optional[str] = '', meshVars: Optional[list] = [], swarmVars: Optional[list] = [], meshUpdates: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the selected mesh, variables and swarm variables (as proxies) for later visualisation.
An xdmf file is generated and the overall package can then be read by paraview or pyvista.
Vertex values (on the mesh points) are stored for all variables regardless of their interpolation order</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="underworld3" href="index.html">underworld3</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="underworld3.discretisation.MeshVariable" href="#underworld3.discretisation.MeshVariable">MeshVariable</a></code></li>
<li><code><a title="underworld3.discretisation.checkpoint_xdmf" href="#underworld3.discretisation.checkpoint_xdmf">checkpoint_xdmf</a></code></li>
<li><code><a title="underworld3.discretisation.meshVariable_lookup_by_symbol" href="#underworld3.discretisation.meshVariable_lookup_by_symbol">meshVariable_lookup_by_symbol</a></code></li>
<li><code><a title="underworld3.discretisation.petsc_dm_find_labeled_points_local" href="#underworld3.discretisation.petsc_dm_find_labeled_points_local">petsc_dm_find_labeled_points_local</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="underworld3.discretisation.Mesh" href="#underworld3.discretisation.Mesh">Mesh</a></code></h4>
<ul class="">
<li><code><a title="underworld3.discretisation.Mesh.CoordinateSystem" href="#underworld3.discretisation.Mesh.CoordinateSystem">CoordinateSystem</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.Gamma" href="#underworld3.discretisation.Mesh.Gamma">Gamma</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.Gamma_N" href="#underworld3.discretisation.Mesh.Gamma_N">Gamma_N</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.N" href="#underworld3.discretisation.Mesh.N">N</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.X" href="#underworld3.discretisation.Mesh.X">X</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.access" href="#underworld3.discretisation.Mesh.access">access</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.block_vars" href="#underworld3.discretisation.Mesh.block_vars">block_vars</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.cdim" href="#underworld3.discretisation.Mesh.cdim">cdim</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.clone_dm_hierarchy" href="#underworld3.discretisation.Mesh.clone_dm_hierarchy">clone_dm_hierarchy</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.data" href="#underworld3.discretisation.Mesh.data">data</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.deform_mesh" href="#underworld3.discretisation.Mesh.deform_mesh">deform_mesh</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.dim" href="#underworld3.discretisation.Mesh.dim">dim</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.generate_xdmf" href="#underworld3.discretisation.Mesh.generate_xdmf">generate_xdmf</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.get_closest_cells" href="#underworld3.discretisation.Mesh.get_closest_cells">get_closest_cells</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.get_closest_local_cells" href="#underworld3.discretisation.Mesh.get_closest_local_cells">get_closest_local_cells</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.get_max_radius" href="#underworld3.discretisation.Mesh.get_max_radius">get_max_radius</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.get_min_radius" href="#underworld3.discretisation.Mesh.get_min_radius">get_min_radius</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.get_min_radius_old" href="#underworld3.discretisation.Mesh.get_min_radius_old">get_min_radius_old</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.lvec" href="#underworld3.discretisation.Mesh.lvec">lvec</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.meshVariable_mask_from_label" href="#underworld3.discretisation.Mesh.meshVariable_mask_from_label">meshVariable_mask_from_label</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.mesh_instances" href="#underworld3.discretisation.Mesh.mesh_instances">mesh_instances</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.nuke_coords_and_rebuild" href="#underworld3.discretisation.Mesh.nuke_coords_and_rebuild">nuke_coords_and_rebuild</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.petsc_save_checkpoint" href="#underworld3.discretisation.Mesh.petsc_save_checkpoint">petsc_save_checkpoint</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.r" href="#underworld3.discretisation.Mesh.r">r</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.rvec" href="#underworld3.discretisation.Mesh.rvec">rvec</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.stats" href="#underworld3.discretisation.Mesh.stats">stats</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.update_lvec" href="#underworld3.discretisation.Mesh.update_lvec">update_lvec</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.vars" href="#underworld3.discretisation.Mesh.vars">vars</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.view" href="#underworld3.discretisation.Mesh.view">view</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.view_parallel" href="#underworld3.discretisation.Mesh.view_parallel">view_parallel</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.vtk" href="#underworld3.discretisation.Mesh.vtk">vtk</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.write" href="#underworld3.discretisation.Mesh.write">write</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.write_checkpoint" href="#underworld3.discretisation.Mesh.write_checkpoint">write_checkpoint</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.write_timestep" href="#underworld3.discretisation.Mesh.write_timestep">write_timestep</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
