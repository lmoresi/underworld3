[
  {
    "objectID": "Notebooks/Notebook_Index.html",
    "href": "Notebooks/Notebook_Index.html",
    "title": "Tutorials",
    "section": "",
    "text": "Underworld is designed to be run in the jupyter notebook environment where you can take advantage of jupyter’s rich display capabilities to explore the mathematics of your problem, visualise results and query classes or live objects.\nYou will find it helpful for developing scripts and analysing results. If you use jupytext to write notebooks directly as python scripts, then the same notebook codes will run on a parallel machine with no performance penalty.\nThe notebooks are rendered as html pages in this guide. They are distributed with the source code on GitHub and can be run on binder.\n\n\nNotebook 1 - Meshes\nMeshes: Introduces the mesh discretisation that we use in Underworld3 and how you can build one of the pre-defined meshes. This notebook also show you how to use the pyvista visualisation tools for Underworld3 objects. The mesh holds information on the mesh geometry, boundaries and coordinate systems.\n\n\nNotebook 2 - Mesh Variables\nVariables: Introduces the concept of MeshVariables in Underworld3. These are both data containers and sympy symbolic objects. We show you how to inspect a meshVariable, set the data values in the MeshVariable and visualise them.\n\n\nNotebook 3 - Symbols and sympy\nSymbols: meshVariables are sympy objects that can be composed with other symbolic objects and evaluated numerically when required. They can also be differentiated. Most importantly, sympy can manipulate expressions, simplify them and cancel terms.\n\n\nNotebook 4 - Example: Diffusion Equation\nDiffusion Solver: Introduces the various solver templates that are available in Underworld, starting with a steady-state diffusion problem. The template requires you to set some constitutive properties and define the unknowns. These are handled through subsitution into symbolic forms and the template equation can be inspected before you need to supply concrete expressions.\n\n\nNotebook 5 - Example: Stokes Equation\nStokes Solver: Stokes equation is a more complicated system of equations to solve. This complexity is mostly hidden when you set the problem up. There are some interesting ways to constrain boundary values which are demonstrated using an annulus mesh (curved, free-slip boundaries) and a \\(\\delta\\) function buoyancy source.\n\n\nNotebook 6 - Example: Time Dependence\nTimestepping: Coupled Stokes flow plus thermal advection-diffusion gives a simple convection solver. The timestepping loop is written by hand because usually you will want to do some analysis or output some checkpoints.\n\n\nNotebook 7 - Example: Navier-Stokes Equation\nUnsteady flow Using a passive swarm to track the pattern of flow developing in a pipe after an impulsive application of a boundary condition at the inflow. Particles need to be added to the passive swarm close to the inflow at each timestep.\n\n\nNotebook 8 - Lagrangian Swarm Variables\nSwarm Variables - exploring how they work for specifying material properties with a swarm used to determine element viscosity. We learn how to use swarm variables in expressions generally and for boundary conditions.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorials</span>"
    ]
  },
  {
    "objectID": "Notebooks/1-Meshes.html",
    "href": "Notebooks/1-Meshes.html",
    "title": "Notebook 1: Meshes",
    "section": "",
    "text": "Introducing meshes: how to build them, interogate them and visualise them.\n\nmesh.view()\nMesh refinement options\nMesh coordinates\nMesh coordinate systems\nMesh deformation\n\nMesh adaptivity is a work-in-progress.\n\nimport underworld3 as uw\nimport numpy as np\nimport sympy\n\n\nUnderworld meshing module\nUnderworld can read mesh definition files from the gmsh package but there are some constraints on how to specify boundaries if those meshes are to be used to solve numerical problems.\nThe underworld.meshing module has a collection of gmsh (python) examples for common, simple meshes.\n\nmesh = uw.meshing.uw.meshing.CubedSphere(\n    radiusOuter=1.0,\n    radiusInner=0.547,\n    numElements=8,\n    refinement=0,\n    simplex=False,\n    verbose=False,\n)\n\n\n\nMesh coordinate arrays\nIf you need to check the physical coordinates of the mesh, there is a data array\n    mesh.data\nwhich is a read-only numpy view of the coordinates (on the local segment of the mesh when running in parallel)\n\nmesh.data\n\narray([[ 0.57735027,  0.57735027, -0.57735027],\n       [-0.57735027,  0.57735027, -0.57735027],\n       [-0.57735027, -0.57735027, -0.57735027],\n       ...,\n       [ 0.58691901, -0.41511058, -0.41511058],\n       [ 0.6269543 , -0.44342636, -0.44342636],\n       [ 0.66698958, -0.47174214, -0.47174214]])\n\n\nThere are other pre-built meshes you can try. This is a cuboid divided into regular tetrahedra:\nmesh_usb = uw.meshing.UnstructuredSimplexBox(\n    minCoords = (-1.0, -1.0, -1.0),\n    maxCoords = (+1.0, +1.0, +1.0),\n    cellSize = 0.2,\n    regular=True,\n    verbose=False,\n)\nand this is a two-dimensional annulus mesh\nmesh_ann = uw.meshing.Annulus(\n    radiusOuter=1.0,\n    radiusInner=0.547,\n    cellSize= 0.5,\n    cellSizeOuter=0.033,\n    cellSizeInner=0.05,\n    verbose=False,\n)\nThe meshing infrastructure for underworld3 is documented here: https://underworldcode.github.io/underworld3/main_api/underworld3/meshing.html\n\nimport pyvista as pv\nimport underworld3.visualisation as vis\n\n# Try out each one !\n\npvmesh = vis.mesh_to_pv_mesh(mesh)\npvmesh.point_data[\"z\"] = vis.scalar_fn_to_pv_points(pvmesh, mesh.CoordinateSystem.X[2])\n\nif mesh.dim==3:\n    pvmesh_c = pvmesh.clip( normal='z', crinkle=True, inplace=False, origin=(0.0,0.0,0.01))\n\npl = pv.Plotter(window_size=(750, 750))\npl.add_mesh(pvmesh_c, show_edges=True, show_scalar_bar=False, opacity=1.0)\npl.add_mesh(pvmesh, show_edges=True, show_scalar_bar=False, opacity=0.3)\n\n\n# Save and show the mesh\npl.export_html(\"html5/spherical_mesh_plot.html\") \n\n\nfrom IPython.display import IFrame\nIFrame(src=\"html5/spherical_mesh_plot.html\", width=600, height=400)\n\n\n        \n        \nInteractive Image: Spherical shell mesh cut in half and overlain with transparent view of the whole mesh. Cubed sphere discretisation using hexahedral elements\n\n\n\n\nCoordinate systems\nThe mesh has an associated “natural” coordinate system (usually Cartesian), but it may also have other, more convenient, coordinate systems.\nFor example, the spherical mesh above has a Cartesian coordinate system which is the one used to navigate the mesh and describe the location of each point. It also has a spherical \\((r, \\theta, \\phi)\\) system which is symbolic and can be expanded in terms of the Cartesian coordinates.\n\n## The coordinate system\n\nX = mesh.CoordinateSystem.X\nR = mesh.CoordinateSystem.R\n\ndisplay(X)\ndisplay(R)\ndisplay(uw.function.expression.unwrap(R))\n\n\\(\\displaystyle \\left[\\begin{matrix}\\mathrm{x} & \\mathrm{y} & \\mathrm{z}\\end{matrix}\\right]\\)\n\n\n\\(\\displaystyle \\left[\\begin{matrix}{ r \\hspace{ 0.0pt } } & { \\theta \\hspace{ 0.01pt } } & { \\phi \\hspace{ 0.02pt } }\\end{matrix}\\right]\\)\n\n\n\\(\\displaystyle \\left[\\begin{matrix}\\sqrt{\\mathrm{x}^{2} + \\mathrm{y}^{2} + \\mathrm{z}^{2}} & \\operatorname{acos}{\\left(\\frac{\\mathrm{z}}{\\sqrt{\\mathrm{x}^{2} + \\mathrm{y}^{2} + \\mathrm{z}^{2}}} \\right)} & \\operatorname{atan}_{2}{\\left(\\mathrm{y},\\mathrm{x} \\right)}\\end{matrix}\\right]\\)\n\n\n\n\nMesh information\nmesh.view() allows you to interrogate the mesh to identify the mesh data structures (which means you can find by name any variable that is automatically constructed by, for example, one of the numerical solvers).\nIt also identifies boundaries of the mesh and their sizes when distributed in parallel. There is a PETSc equivalent which is also called and this contains low-level information on the mesh topology.\n\nmesh.view()\n\n\n\nMesh # 0: .meshes/uw_cubed_spherical_shell_ro1.0_ri0.547_elts8_plexFalse.msh\n\nNo variables are defined on the mesh\n\n| Boundary Name            | ID    | Min Size | Max Size |\n| ------------------------------------------------------ |\n| Lower                    | 1     | 678      | 678      |\n| Upper                    | 2     | 678      | 678      |\n| All_Boundaries           | 1001  | 768      | 768      |\n| UW_Boundaries            | --    | 1356     | 1356     |\n| ------------------------------------------------------ |\n\n\nDM Object: uw_.meshes/uw_cubed_spherical_shell_ro1.0_ri0.547_elts8_plexFalse.msh 1 MPI process\n  type: plex\nuw_.meshes/uw_cubed_spherical_shell_ro1.0_ri0.547_elts8_plexFalse.msh in 3 dimensions:\n  Number of 0-cells per rank: 3474\n  Number of 1-cells per rank: 10000\n  Number of 2-cells per rank: 9600\n  Number of 3-cells per rank: 3072\nLabels:\n  depth: 4 strata with value/size (0 (3474), 1 (10000), 2 (9600), 3 (3072))\n  All_Boundaries: 1 strata with value/size (1001 (768))\n  Elements: 1 strata with value/size (99999 (5130))\n  Lower: 1 strata with value/size (1 (678))\n  Upper: 1 strata with value/size (2 (678))\n  celltype: 4 strata with value/size (0 (3474), 1 (10000), 4 (9600), 7 (3072))\n  UW_Boundaries: 2 strata with value/size (1 (678), 2 (678))\n\n\n\n\nMesh deformation\nYou can adjust the coordinates using:\n    mesh.deform(local_coordinate_array)\nThis rebuilds all the finite element gadgets that live on the mesh but it will not do any remeshing of the points. It is useful for small deformation such as following a free surface but not large-deformation adaptive meshing.\nSee Notebook 8 for a short mesh-deformation example.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Notebook 1: Meshes</span>"
    ]
  },
  {
    "objectID": "Notebooks/2-Variables.html",
    "href": "Notebooks/2-Variables.html",
    "title": "Notebook 2: Variables",
    "section": "",
    "text": "More information\nThe meshVariable code is described in the API docs: https://underworldcode.github.io/underworld3/main_api/underworld3/meshing.html",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Notebook 2: Variables</span>"
    ]
  },
  {
    "objectID": "Notebooks/3-Symbolic_Forms.html",
    "href": "Notebooks/3-Symbolic_Forms.html",
    "title": "Notebook 3: Symbolic forms",
    "section": "",
    "text": "Symbolic forms, derivatives\nVariables can be part of complicated sympy expressions. It is important to note that all symbols are matrices and sympy can be fussy when it comes to operations with other matrices (scalars are not entirely equivalent to \\(1 \\times 1\\) matrices).\ns.sym[0]+t.sym[0] + v.sym[0]\n\n\\(\\displaystyle {\\cal{S}}(\\mathbf{x}) + {\\cal{T}}(\\mathbf{x}) + {\\mathbf{v}}_{ 0 }(\\mathbf{x})\\)\nDerivatives can be handled explicitly, but the mesh also provides vector operators and these are generally better because they are automatically consistent with the underlying coordinate system for the mesh.\nFor compound expressions of variables, use mesh.vector.curl(expression) but for individual variables, variable.curl() is an equivalent shorthand.\n# grad by hand\ns.sym[0].diff(x) + s.sym[0].diff(y)\n\n\\(\\displaystyle {\\cal{S}}_{,0}(\\mathbf{x}) + {\\cal{S}}_{,1}(\\mathbf{x})\\)\n# grad\ns.gradient()\n\n\\(\\displaystyle \\left[\\begin{matrix}{\\cal{S}}_{,0}(\\mathbf{x}) & {\\cal{S}}_{,1}(\\mathbf{x})\\end{matrix}\\right]\\)\nv.curl()\n\n\\(\\displaystyle - {\\mathbf{v}}_{ 0,1}(\\mathbf{x}) + {\\mathbf{v}}_{ 1,0}(\\mathbf{x})\\)\n# curl\nmesh.vector.curl(s.sym * v.sym)\n\n\\(\\displaystyle - {\\cal{S}}(\\mathbf{x}) {\\mathbf{v}}_{ 0,1}(\\mathbf{x}) + {\\cal{S}}(\\mathbf{x}) {\\mathbf{v}}_{ 1,0}(\\mathbf{x}) + {\\cal{S}}_{,0}(\\mathbf{x}) {\\mathbf{v}}_{ 1 }(\\mathbf{x}) - {\\cal{S}}_{,1}(\\mathbf{x}) {\\mathbf{v}}_{ 0 }(\\mathbf{x})\\)\n# v dot grad (scalar)... \nv.sym.dot(mesh.vector.gradient(s.sym))\n\n\\(\\displaystyle {\\cal{S}}_{,0}(\\mathbf{x}) {\\mathbf{v}}_{ 0 }(\\mathbf{x}) + {\\cal{S}}_{,1}(\\mathbf{x}) {\\mathbf{v}}_{ 1 }(\\mathbf{x})\\)",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Notebook 3: Symbolic forms</span>"
    ]
  },
  {
    "objectID": "Notebooks/3-Symbolic_Forms.html#symbolic-forms-derivatives",
    "href": "Notebooks/3-Symbolic_Forms.html#symbolic-forms-derivatives",
    "title": "Notebook 3: Symbolic forms",
    "section": "",
    "text": "Underworld Expressions\nWe often want to define symbols that represent complicated expressions which we want do not want to expand when we probe the mathematical formulation.\nAn example might be a constitutive model that has a number of conditional expressions, or a concept such as a timestep which we want to refer to as \\(\\delta t\\) regardless of its current numerical value.\nUnderworld expressions are objects that have a sympy symbolic representation that is only expanded at the time numerical evaluations are required. How about the example above in expression form:\n    curl_sv = uw.function.expression(\n                    r\"\\nabla \\times \\left(\\cal{S} \\mathbf{v}\\right)\",\n                    mesh.vector.curl(s.sym * v.sym),\n                    f\"Curl of {v.symbol}\"\n                ) \ncreates an expression object which displays as \\(\\nabla \\times \\left(\\cal{S} \\mathbf{v}\\right)\\) but which also has curl_sv.sym which is the full expression.\n\ncurl_sv = uw.function.expression(\n                    r\"\\nabla \\times \\left(\\cal{S} \\mathbf{v}\\right)\",\n                    mesh.vector.curl(s.sym * v.sym),\n                    rf\"Curl of {v.symbol}\"\n                ) \n\ncurl_sv.view()\ndisplay(curl_sv.sym) \n\ncurl_sv + 1\n\nClass: &lt;class ‘underworld3.function.expressions.UWexpression’&gt;\n\n\n\\(\\quad\\)\\(\\displaystyle { \\nabla \\times \\left(\\cal{S} \\mathbf{v}\\right) \\hspace{ 0.0pt } }\\)\\(=\\)\\(\\displaystyle - {\\cal{S}}(\\mathbf{x}) {\\mathbf{v}}_{ 0,1}(\\mathbf{x}) + {\\cal{S}}(\\mathbf{x}) {\\mathbf{v}}_{ 1,0}(\\mathbf{x}) + {\\cal{S}}_{,0}(\\mathbf{x}) {\\mathbf{v}}_{ 1 }(\\mathbf{x}) - {\\cal{S}}_{,1}(\\mathbf{x}) {\\mathbf{v}}_{ 0 }(\\mathbf{x})\\)\n\n\n\\(\\quad\\)Description: Curl of {}\n\n\n\\(\\displaystyle - {\\cal{S}}(\\mathbf{x}) {\\mathbf{v}}_{ 0,1}(\\mathbf{x}) + {\\cal{S}}(\\mathbf{x}) {\\mathbf{v}}_{ 1,0}(\\mathbf{x}) + {\\cal{S}}_{,0}(\\mathbf{x}) {\\mathbf{v}}_{ 1 }(\\mathbf{x}) - {\\cal{S}}_{,1}(\\mathbf{x}) {\\mathbf{v}}_{ 0 }(\\mathbf{x})\\)\n\n\n\\(\\displaystyle { \\nabla \\times \\left(\\cal{S} \\mathbf{v}\\right) \\hspace{ 0.0pt } } + 1\\)\n\n\n\n\nUnderworld Sub-expressions\nThe viscosity for a material with a yield stress might look like this:\n\\[\n\\eta_\\textrm{eff} = \\displaystyle \\min\\left({  {\\eta} }, \\frac{\\max\\left({ {\\tau_{y}} }, {  {\\tau_{y, \\mathrm{min}}} }\\right)}{2 {  \\dot\\varepsilon_{II} }}\\right)\n\\]\nwhere \\(\\tau_y\\) is a scalar yield stress, and \\(\\dot\\varepsilon_{II}\\) is the second invariant of the strain-rate tensor. Each of these would be a nested Underworld expression.\nTo expand the expression and see inside, we can use\n    expression.unwrap(keep_constants=True)\nwhich reaches down the hierarchy and recursively replaces any expression with its expanded sympy representation. If a symbol represents a constant value (float, int, or sympy number), then it is only replaced if keep_constants is set to False.\nSymbolic forms can be evaluated at points in the (meshed domain) using uw.function.evaluate. Pure sympy functions can be used to set values in the data container of a meshVariable object\n\nwith mesh.access(s, t):\n    s.data[:,0] = uw.function.evaluate(sympy.cos(3 * sympy.pi * x)**2 , s.coords)\n    t.data[:,0] = uw.function.evaluate(sympy.sin(3 * sympy.pi * y)**2 , t.coords)\n\n\ns.view()\n\nClass: &lt;class ‘underworld3.discretisation._MeshVariable’&gt;\n\n\nMeshVariable:\n\n\n\nsymbol: \\({\\cal{S}}\\)\n\n\nshape: \\((1, 1)\\)\n\n\ndegree: \\(1\\)\n\n\ncontinuous: True\n\n\ntype: SCALAR\n\n\n\nFE Data:\n\n\n\nPETSc field id: \\(0\\)\n\n\nPETSc field name: S\n\n\n\narray([[1.        ],\n       [1.        ],\n       [1.        ],\n       ...,\n       [0.79389263],\n       [0.79389263],\n       [0.79389263]])\n\n\n\n# Visualise it / them\n\nimport pyvista as pv\nimport underworld3.visualisation as vis\n\npvmesh = vis.mesh_to_pv_mesh(mesh)\npvmesh.point_data[\"s\"] = vis.scalar_fn_to_pv_points(pvmesh, s.sym[0])\npvmesh.point_data[\"t\"] = vis.scalar_fn_to_pv_points(pvmesh, t.sym[0])\npvmesh.point_data[\"sxt\"] = vis.scalar_fn_to_pv_points(pvmesh, s.sym[0]*t.sym[0])\n\npvmesh.warp_by_scalar(scalars=\"sxt\", factor=0.3, normal=(0,0,1), inplace=True)\n\n# pvmesh.plot(show_edges=True, show_scalar_bar=False)\n\npl = pv.Plotter(window_size=(750, 750))\n\npl.add_mesh(pvmesh, \n            show_edges=True,\n            edge_color=\"#4455FF\",\n            cmap=\"Greys\",\n            scalars=\"sxt\", \n            show_scalar_bar=False)\n\n# Save and show the mesh\n\npl.camera_position = 'yz'\npl.camera.azimuth = 45\npl.camera.elevation = 45\n\npl.export_html(\"html5/sine_squared.html\")\n\n\nfrom IPython.display import IFrame\nIFrame(src=\"html5/sine_squared.html\", width=600, height=400)\n\n\n        \n        \nInteractive Image: Square mesh of triangular elements on which we evaluated a simple sympy function of position\n\n\n\nLazy evaluation of expressions\nGenerally speaking, we use expressions as placeholders for parameters or functions that we know will be needed when it comes to solve a problem, but we can’t be sure that we can specify them at the time we set up the solver.\nIn the code for our solvers, for example, we set up a template with expressions that describe where the parameters of the problem will be and we expect you to fill the details in when we create a new solver-object. These template expressions are protected so that assignment just changes the value that the expression holds, it does not change the symbol or the description (though you can do this if you want).\nThis is a rather contrived example:\n\nR = uw.function.expression(r\"r\\left( \\mathbf{x} \\right)\",\n                           sympy.sqrt(x**2+y**2), \n                           \"distance from origin\")\n\nR1 = R + 1\n\nS = sympy.sqrt(x**2+y**2)\nS1 = S + 1\n               \n\n\nR1 = R + 1\nR2 = R.sym + 1\nS1 = S + 1\n\n\nS1\n\n\\(\\displaystyle \\sqrt{\\mathrm{x}^{2} + \\mathrm{y}^{2}} + 1\\)\n\n\n\nR.sym = S = sympy.sqrt((x-1)**2 + (y-1)**2)\n\n\nuw.function.expressions.unwrap(R1) # Lazy evaluation \n\n\\(\\displaystyle \\sqrt{\\left(\\mathrm{x} - 1\\right)^{2} + \\left(\\mathrm{y} - 1\\right)^{2}} + 1\\)\n\n\n\nuw.function.expressions.unwrap(S1)\n\n\\(\\displaystyle \\sqrt{\\mathrm{x}^{2} + \\mathrm{y}^{2}} + 1\\)\n\n\n\nuw.function.expressions.unwrap(R2)\n\n\\(\\displaystyle \\sqrt{\\mathrm{x}^{2} + \\mathrm{y}^{2}} + 1\\)",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Notebook 3: Symbolic forms</span>"
    ]
  },
  {
    "objectID": "Notebooks/3-Symbolic_Forms.html#exercise-3.1",
    "href": "Notebooks/3-Symbolic_Forms.html#exercise-3.1",
    "title": "Notebook 3: Symbolic forms",
    "section": "Exercise 3.1",
    "text": "Exercise 3.1\nHave a look at the visco-plastic constitutive model (template) for Stokes equation\nstokes_solver = uw.systems.solvers.SNES_Stokes(mesh)\nstokes_solver.constitutive_model = uw.constitutive_models.ViscoPlasticFlowModel\nstokes_solver.constitutive_model.Parameters.shear_viscosity_0 = 1\nstokes_solver.constitutive_model.Parameters.yield_stress = 100\nYou can examine this expression in more detail using the view method of the stokes_solver.constitutive_model, and you can expand the expression to see how it reduces when sympy needs to evaluate this expression at one or more locations in the domain.\n\nExercise 3.2\nAssignment to an expression object replaces the sympy value but does not change the rest of the object. This is the concept of lazy evaluation which we introduced earlier.\nValidate this using the constititutive model above. Try changing the yield stress or the shear viscosity and see how the expression for the apparent viscosity changes.\ne.g. \n    stokes_solver.constitutive_model.Parameters.shear_viscosity_0 = sympy.exp(-10 * t.sym[0])\n    display(stokes_solver.constitutive_model.viscosity)\nActually, that won’t look different, will it ? You need to expand out the expressions a bit to see it. Try using stokes_solver.constitutive_model.viscosity.unwrap(). This function makes substitutions of all (underworld) sub-expressions in any sympy expression.\nYou can pass keep_constants=False if you want to expand all the numerical values as well. An expression is considered to be a constant if it contains no sub-expressions, MeshVariables, or mesh-coordinates. We usually do not want to have long floating point numbers all over the place when we check an expression except if it’s the values that we want to check.\nTry it !",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Notebook 3: Symbolic forms</span>"
    ]
  },
  {
    "objectID": "Notebooks/4-Solvers.html",
    "href": "Notebooks/4-Solvers.html",
    "title": "Notebook 4: Poisson Equation",
    "section": "",
    "text": "The Poisson Solver\nThere are a number of pre-defined solver systems defined in underworld3 which are templates for orchestrating the underlying PETSc objects. A solver requires us to define the unknown in the form of meshVariables, provide boundary conditions, a constitutive model, and provide uw.functions to define constitutive properties, and driving terms.\nWe will use the Poisson solver for the diffusion equation, and we will use a Projection solver to compute the vertical gradient term.\nThe solver classes themselves are documented, so we can figure out what is needed before we define anything:\nuw.systems.Poisson.view()\n\nThis class provides functionality for a discrete representation of the Poisson equation\n\\[\n\\nabla \\cdot\n        \\color{Blue}{\\underbrace{\\Bigl[ \\boldsymbol\\kappa \\nabla u \\Bigr]}_{\\mathbf{F}}} =\n        \\color{Maroon}{\\underbrace{\\Bigl[ f \\Bigl] }_{\\mathbf{f}}}\n\\]\nThe term \\(\\mathbf{F}\\) relates the flux to gradients in the unknown \\(u\\)\n\nProperties\n\nThe unknown is \\(u\\)\nThe diffusivity tensor, \\(\\kappa\\) is provided by setting the constitutive_model property to one of the scalar uw.constitutive_models classes and populating the parameters. It is usually a constant or a function of position / time and may also be non-linear or anisotropic.\n\\(f\\) is a volumetric source term\nuw.systems.Projection.view()\n\nSolves \\(u = \\tilde{f}\\) where \\(\\tilde{f}\\) is a function that can be evaluated within an element and \\(u\\) is a meshVariable with associated shape functions. Typically, the projection is used to obtain a continuous representation of a function that is not well defined at the mesh nodes. For example, functions of the spatial derivatives of one or more meshVariable (e.g. components of fluxes) can be mapped to continuous variables with a projection. More broadly it is a projection from one basis to another and its limitations should be evaluated within that context.\nThe projection implemented by creating a solver for this problem\n\\[\n\\nabla \\cdot\n        \\color{Blue}{\\underbrace{\\Bigl[ \\boldsymbol\\alpha \\nabla u \\Bigr]}_{\\mathbf{F}}} -\n        \\color{Maroon}{\\underbrace{\\Bigl[ u - \\tilde{f} \\Bigl] }_{\\mathbf{f}}} = 0\n\\]\nWhere the term \\(\\mathbf{F}\\) provides a smoothing regularization. \\(\\alpha\\) can be zero.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Notebook 4: Poisson Equation</span>"
    ]
  },
  {
    "objectID": "Notebooks/4-Solvers.html#properties",
    "href": "Notebooks/4-Solvers.html#properties",
    "title": "Notebook 4: Poisson Equation",
    "section": "Properties",
    "text": "Properties\n\nThe unknown is \\(u\\)\nThe diffusivity tensor, \\(\\kappa\\) is provided by setting the constitutive_model property to one of the scalar uw.constitutive_models classes and populating the parameters. It is usually a constant or a function of position / time and may also be non-linear or anisotropic.\n\\(f\\) is a volumetric source term",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Notebook 4: Poisson Equation</span>"
    ]
  },
  {
    "objectID": "Notebooks/5-Solvers.html",
    "href": "Notebooks/5-Solvers.html",
    "title": "Notebook 5: Stokes Equation",
    "section": "",
    "text": "Mesh with embedded internal surface where we apply harmonic thermal forcing. This allows us to compute topography and gravity kernels. We’ll use a cylindrical annulus this timeand we’ll use free-slip boundary conditions throughout.\n\nimport underworld3 as uw\nimport numpy as np\nimport sympy\n\n\nres = 0.075\nr_o = 1.0\nr_int = 0.825\nr_i = 0.55\n\n\nmeshball = uw.meshing.AnnulusInternalBoundary(radiusOuter=r_o, \n                                              radiusInternal=r_int, \n                                              radiusInner=r_i, \n                                              cellSize_Inner=res,\n                                              cellSize_Internal=res*0.5,\n                                              cellSize_Outer=res,\n                                              centre=False,)\nmeshball.view()\n\nx, y = meshball.CoordinateSystem.X\nr, th = meshball.CoordinateSystem.xR\nunit_rvec = meshball.CoordinateSystem.unit_e_0\n\n\n# Orientation of surface normals\nGamma_N = unit_rvec\n\n\n\n\nMesh # 0: .meshes/uw_annulus_internalBoundary_rO1.0rInt0.825_rI0.55_csize0.1_csizefs0.075.msh\n\nNo variables are defined on the mesh\n\n| Boundary Name            | ID    | Min Size | Max Size |\n| ------------------------------------------------------ |\n| Lower                    | 1     | 94       | 94       |\n| Internal                 | 2     | 278      | 278      |\n| Upper                    | 3     | 166      | 166      |\n| Centre                   | 10    | 0        | 0        |\n| All_Edges                | 1000  | 0        | 0        |\n| All_Boundaries           | 1001  | 132      | 132      |\n| UW_Boundaries            | --    | 538      | 538      |\n| ------------------------------------------------------ |\n\n\nDM Object: uw_.meshes/uw_annulus_internalBoundary_rO1.0rInt0.825_rI0.55_csize0.1_csizefs0.075.msh 1 MPI process\n  type: plex\nuw_.meshes/uw_annulus_internalBoundary_rO1.0rInt0.825_rI0.55_csize0.1_csizefs0.075.msh in 2 dimensions:\n  Number of 0-cells per rank: 1142\n  Number of 1-cells per rank: 3294\n  Number of 2-cells per rank: 2152\nLabels:\n  depth: 3 strata with value/size (0 (1142), 1 (3294), 2 (2152))\n  All_Boundaries: 1 strata with value/size (1001 (132))\n  Elements: 1 strata with value/size (666666 (3022))\n  Internal: 1 strata with value/size (2 (278))\n  Lower: 1 strata with value/size (1 (94))\n  Upper: 1 strata with value/size (3 (166))\n  celltype: 3 strata with value/size (0 (1142), 1 (3294), 3 (2152))\n  UW_Boundaries: 3 strata with value/size (1 (94), 2 (278), 3 (166))\n\n\n\nSolver setup\nWe can obtain unit vectors in the natural coordinate system (here \\(r\\), \\(\\theta\\)) as mesh.CoordinateSystem.unit_e_0, mesh.CoordinateSystem.unit_e_1. There is a null space if we apply the boundary conditions exactly, and so we define a function to represent the null space.\nWe can set solver options via the petsc_options interface on the solver.\n\n# Create a density structure / buoyancy force\n# gravity will vary linearly from zero at the centre\n# of the sphere to (say) 1 at the surface\n\n\n# Null space in velocity (constant v_theta) expressed in x,y coordinates\nv_theta_fn_xy = r * meshball.CoordinateSystem.rRotN.T * sympy.Matrix((0,1))\n\n# Mesh variables for the unknowns\n\nv_soln = uw.discretisation.MeshVariable(\"V0\", meshball, 2, degree=2, varsymbol=r\"{v_0}\")\np_soln = uw.discretisation.MeshVariable(\"p\", meshball, 1, degree=1, continuous=True)\n\nstokes = uw.systems.Stokes(\n    meshball, velocityField=v_soln, pressureField=p_soln, solver_name=\"stokes\"\n)\n\nstokes.constitutive_model = uw.constitutive_models.ViscousFlowModel\nstokes.constitutive_model.Parameters.shear_viscosity_0 = 1\nstokes.tolerance = 1.0e-6\n\nstokes.petsc_options.setValue(\"ksp_monitor\", None)\nstokes.petsc_options.setValue(\"snes_monitor\", None)\nstokes.petsc_options[\"fieldsplit_velocity_mg_coarse_pc_type\"] = \"svd\"\n\n\n\nNatural boundary conditions\nIn FEM, natural boundary conditions are fluxes specified at a boundary (through surface integrals). We can also apply integrals to internal surfaces. We need to compute the vector components of the boundary condition (normal / tangential) and supply them in the Cartesian frame.\nThe bouyancy force on the internal surface is already radial, so this translates to\n    stokes.add_natural_bc(-t_init * unit_rvec, \"Internal\")\nTo set a no-normal-flow boundary condition, we need to penalise the radial velocity at the boundaries. Symbolically this is\n\\[\n    \\mathbf{f} = \\lambda \\left( \\mathbf{v} \\cdot \\Gamma_N \\right) \\,\\, \\Gamma_N\n\\]\nwhere \\(\\lambda\\) is a large penalty value. This translates into sympy code as\n    stokes.add_natural_bc(\n                penalty * Gamma_N.dot(v_soln.sym) *  Gamma_N, \"Lower\"\n                )\n\n\nstokes.bodyforce = sympy.Matrix([0,0])\n\n# Note, the thermal bouyancy field is localised in the radius using a \n# gaussian solely for the purposes of plotting. It is automatically\n# a delta function when applied through a surface integral\n\nt_init = sympy.sin(5*th) * sympy.exp(-1000.0 * ((r - r_int) ** 2)) \n\nstokes.add_natural_bc(-t_init * unit_rvec, \"Internal\")\nstokes.add_natural_bc(10000 * Gamma_N.dot(v_soln.sym) *  Gamma_N, \"Upper\")\n\nif r_i != 0.0:\n    stokes.add_natural_bc(10000 * Gamma_N.dot(v_soln.sym) *  Gamma_N, \"Lower\")\n\nstokes.solve()\n\n  0 SNES Function norm 2.307507502179e-01\n    Residual norms for stokes_ solve.\n    0 KSP Residual norm 8.742204758135e+00\n    1 KSP Residual norm 7.603223176805e-07\n  1 SNES Function norm 4.751452850114e-08\n\n\n\n\nRemoval of the null space\nWe can use the uw.maths.Integral to compute the inner product of the null space and the velocity solution. It is not zero, so we remove it !\n\n# Null space evaluation\n\nI0 = uw.maths.Integral(meshball, v_theta_fn_xy.dot(v_theta_fn_xy))\nvnorm = I0.evaluate()\n                                  \nI0.fn = v_theta_fn_xy.dot(v_soln.sym)\nns = I0.evaluate()\n\nprint(ns/vnorm, vnorm)\n\nwith meshball.access(v_soln):\n    dv = uw.function.evaluate(ns * v_theta_fn_xy, v_soln.coords) / vnorm\n    v_soln.data[...] -= dv \n\nns = I0.evaluate()\nprint(ns/vnorm, vnorm)\n\n0.0005624988949826505 1.4249504223200373\n1.9675625281382883e-19 1.4249504223200373\n\n\n\n\nif uw.mpi.size == 1:\n    import pyvista as pv\n    import underworld3.visualisation as vis\n\n    pvmesh = vis.mesh_to_pv_mesh(meshball)\n    pvmesh.point_data[\"P\"] = vis.scalar_fn_to_pv_points(pvmesh, p_soln.sym)\n    pvmesh.point_data[\"V\"] = vis.vector_fn_to_pv_points(pvmesh, v_soln.sym)\n    pvmesh.point_data[\"T\"] = vis.scalar_fn_to_pv_points(pvmesh, t_init)\n    \n    skip = 1\n    points = np.zeros((meshball._centroids[::skip].shape[0], 3))\n    points[:, 0] = meshball._centroids[::skip, 0]\n    points[:, 1] = meshball._centroids[::skip, 1]\n    point_cloud = pv.PolyData(points)\n\n    pvstream = pvmesh.streamlines_from_source(\n        point_cloud, vectors=\"V\", \n        integration_direction=\"both\", \n        integrator_type=45,\n        surface_streamlines=True,\n        initial_step_length=0.01,\n        max_time=0.5,\n        max_steps=500, \n    )\n   \n\n    pl = pv.Plotter(window_size=(750, 750))\n\n    pl.add_mesh(\n        pvmesh,\n        cmap=\"coolwarm\",\n        edge_color=\"Grey\",\n        edge_opacity=0.33,\n        scalars=\"T\",\n        show_edges=True,\n        use_transparency=False,\n        opacity=1.0,\n        show_scalar_bar=False\n    )\n\n\n    pl.add_mesh(pvstream, opacity=0.3, show_scalar_bar=False, cmap=\"Greens\", render_lines_as_tubes=False)\n\n    pl.export_html(\"html5/stokes_annulus_plot.html\")\n\n\nfrom IPython.display import IFrame\nIFrame(src=\"html5/stokes_annulus_plot.html\", width=500, height=400)\n\n\n        \n        \nInteractive Image: Annulus mesh of triangular elements on which we evaluated Stokes flow driven by an internal delta function buoyancy. Boundary conditions are free slip, imposed using a penalty on the radial velocity at the boundary",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Notebook 5: Stokes Equation</span>"
    ]
  },
  {
    "objectID": "Notebooks/6-Timestepping.html",
    "href": "Notebooks/6-Timestepping.html",
    "title": "Notebook 6: Time-dependence",
    "section": "",
    "text": "Create linked solvers\nWe create the Stokes solver as we did in the previous notebook. The buoyancy force is proportional to the temperature anomaly (t_soln). Solvers can either be provided with unknowns as pre-defined meshVariables, or they will define their own. When solvers are coupled, explicitly defining unknowns makes everything clearer.\nThe advection-diffusion solver evolved t_soln using the Stokes velocity v_soln in the fluid-transport term.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Notebook 6: Time-dependence</span>"
    ]
  },
  {
    "objectID": "Notebooks/6-Timestepping.html#exercise---null-space",
    "href": "Notebooks/6-Timestepping.html#exercise---null-space",
    "title": "Notebook 6: Time-dependence",
    "section": "Exercise - Null space",
    "text": "Exercise - Null space\nBased on our previous notebook, can you see how to calculate and (if necessary) remove rigid-body the rotation null-space from the solution ?\nThe use of a coarse-level singular-value decomposition for the velocity solver should help, here, but it’s wise to check anyway.\n    stokes.petsc_options[\"fieldsplit_velocity_mg_coarse_pc_type\"] = \"svd\"",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Notebook 6: Time-dependence</span>"
    ]
  },
  {
    "objectID": "Notebooks/6-Timestepping.html#exercise---heat-flux",
    "href": "Notebooks/6-Timestepping.html#exercise---heat-flux",
    "title": "Notebook 6: Time-dependence",
    "section": "Exercise - Heat flux",
    "text": "Exercise - Heat flux\nCould you calculate the radial heat flux field ? Its surface average value plotted against time tells you if you have reached a steady state.\nHint:\n\\[\n    Q_\\textrm{surf} = \\nabla T \\cdot \\hat{r} + T (\\mathbf{v} \\cdot \\hat{r} )\n\\]\n    Q_surf = -meshball.vector.gradient(t_soln.sym).dot(unit_rvec) +\\\n                    t_soln.sym[0] * v_soln.sym.dot(unit_rvec)",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Notebook 6: Time-dependence</span>"
    ]
  },
  {
    "objectID": "Notebooks/7-Unsteady_Flow.html",
    "href": "Notebooks/7-Unsteady_Flow.html",
    "title": "Notebook 7: Unsteady Flow",
    "section": "",
    "text": "Exercise - 7.1\nNow that you have seen the structure of the flow in this example, can you adjust the addition of particles to capture the structure more clearly ?\nThis is a very low-resolution example. You can try increasing the resolution but you will see that this would benefit from running in parallel. In parallel we should remove all the visualisation and visualise the h5 output files when we are done. The rest of the code is parallel-safe.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Notebook 7: Unsteady Flow</span>"
    ]
  },
  {
    "objectID": "Notebooks/8-Particle_Swarms.html",
    "href": "Notebooks/8-Particle_Swarms.html",
    "title": "Notebook 8: Particle Swarms",
    "section": "",
    "text": "Deform the mesh\nMove all nodes down to meet an undulating lower surface. The displacement field is smooth and continuous, so there is no particular need to remesh in this case. However, it is generally better to consider either deforming the mesh with gmsh before triangulation, or remeshing (both are possible with underworld3, but not as simple to demonstrate).\nnew_coords = mesh.data\ndy =  (1-y) * (sympy.sin(sympy.pi * x)/10) \nnew_coords[:,1] = uw.function.evalf(y-dy, mesh.data)\n\ndisplay(dy)\n\nmesh.deform_mesh(new_coords)\n\n\\(\\displaystyle \\frac{\\left(1 - \\mathrm{y}\\right) \\sin{\\left(\\mathrm{x} \\pi \\right)}}{10}\\)\n# y coordinate after 1st deformation\ny1 = uw.discretisation.MeshVariable(\"Y1\", \n                                    mesh, \n                                    vtype=uw.VarType.SCALAR,\n                                    varsymbol=r\"y_1\")\n\nwith mesh.access(y1):\n    y1.data[:,0] = uw.function.evalf(y, y1.coords)",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Notebook 8: Particle Swarms</span>"
    ]
  },
  {
    "objectID": "Notebooks/8-Particle_Swarms.html#exercise---8.1",
    "href": "Notebooks/8-Particle_Swarms.html#exercise---8.1",
    "title": "Notebook 8: Particle Swarms",
    "section": "Exercise - 8.1",
    "text": "Exercise - 8.1\nLook at the Stokes example and try with a free slip base and low / high viscosity for the trapped material. You could also see what mixing the boundary condition looks like: free slip in the troughs, fixed in the highs. This is possible with a single boundary condition if you use sympy.Piecewise to switch between different penalty conditions.\n\n    ## Free slip base (conditional)\n\n    Gamma = mesh.Gamma\n    GammaNorm = uw.function.expression(r\"|\\Gamma|\", sympy.sqrt(Gamma.dot(Gamma)), \"Scaling for surface normals\")\n    GammaN = Gamma / GammaNorm\n    \n    bc_mask = sympy.Piecewise((1.0, y1.sym[0] &lt; -0.05), (0.0, True))\n    nbc = 10000 * bc_mask * GammaN.dot(v_soln.sym) *  GammaN + (1-bc_mask) * v_soln.sym            \n    stokes.add_natural_bc(nbc, \"Lower\")\nGive that a try !",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Notebook 8: Particle Swarms</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Underworld3 Quick Start Guide",
    "section": "",
    "text": "Installation Guide\nThe quickest option is not to install anything but click on the rocket icon (top right) to launch our notebook examples on mybinder.org. If do you want to install the code on your own machine, we recommend using miniconda and mamba and to create a separate virtual environment and to install the code from source.\nMore details in the Installation Instructions",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "index.html#notebooks",
    "href": "index.html#notebooks",
    "title": "Underworld3 Quick Start Guide",
    "section": "Notebooks",
    "text": "Notebooks\nUnderworld is designed to be run in the jupyter notebook environment where you can take advantage of jupyter’s rich display capabilities to explore the mathematics of your problem, visualise results and query classes or live objects.\nIt’s a good first step after you install the code to look at the examples notebooks. When you are happy that things are working OK, you can move along to look at the full documentation or the benchmarking repository.\nSummary of skills that the notebooks cover",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "index.html#next-steps",
    "href": "index.html#next-steps",
    "title": "Underworld3 Quick Start Guide",
    "section": "Next Steps",
    "text": "Next Steps\nSome of the cool things about UW3 that you can do with a bit of effort (at the moment)\n\ngmsh (anything - Pramoda’s work)\ndeformed meshes, interesting boundary conditions\nfree surfaces, relaxation etc",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "index.html#documentation-cookbooks",
    "href": "index.html#documentation-cookbooks",
    "title": "Underworld3 Quick Start Guide",
    "section": "Documentation & Cookbooks",
    "text": "Documentation & Cookbooks",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Underworld3 Quick Start Guide",
    "section": "References",
    "text": "References",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "NextSteps.html",
    "href": "NextSteps.html",
    "title": "Next Steps",
    "section": "",
    "text": "Underworld Documentation and Examples\n\n\nBenchmarks\n\n\nThe Underworld Community\nSharing codes / fixes\nSharing models\n\n\nParallel Execution\nAdvise using jupytext to render notebooks at .py files. This is helpful in shared environments because the files contain no output and play better with version control.\nNot such a good idea if you want to have a tutorial with outputs (like this one)",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Next Steps</span>"
    ]
  },
  {
    "objectID": "Installation.html",
    "href": "Installation.html",
    "title": "Installation Guide",
    "section": "",
    "text": "Windows users, if you don’t want to create a linux partition, you can use our containers.",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Installation Guide</span>"
    ]
  }
]